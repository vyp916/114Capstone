<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Live Stream Broadcaster</title>
  <link rel="stylesheet" href="style-modern.css">
  <!-- æ‰‹æ©Ÿç›¸å®¹æ€§ä¿®å¾© -->
  <script src="mobile-fix.js"></script>

  <style>
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .emoji-particle { will-change: transform, opacity; z-index: 99999; pointer-events: none; }
    #reactionValve { user-select: none; }
  </style>

</head>
<body>
  <h1>ğŸ“¡ Broadcast Panel</h1>

  <!-- ğŸ†• æˆ¿é–“èˆ‡ç‹€æ…‹è³‡è¨Š -->
  <div id="infoBar" style="text-align:center;">
    <p>æˆ¿é–“è™Ÿï¼š<span id="roomCode">---</span></p>
    <button id="shareBtn">ğŸ“¤ åˆ†äº«é€£çµ</button>
    <button id="diagBtn" style="margin-left:6px;padding:4px 8px;font-size:12px;">ğŸ”§ è¨ºæ–·é¢æ¿</button>
    <p>ğŸ‘¥ åœ¨ç·šäººæ•¸ï¼š<span id="viewerCount">0</span>
      <span id="topReaction" style="margin-left:12px; font-size:14px;"> </span>
      <span id="reactionPulse" aria-hidden="true" style="display:inline-block;width:10px;height:10px;background:#ff4081;border-radius:50%;margin-left:8px;opacity:0;transform:scale(0.8);transition:opacity 220ms, transform 220ms;"></span>
    </p>
  </div>

  <!-- è¨ºæ–·é¢æ¿ -->
  <div id="diagPanel" style="display:none;background:#1a1a1a;color:#0f0;border:1px solid #0f0;border-radius:6px;padding:12px;margin:8px;font-family:monospace;font-size:11px;max-height:200px;overflow:auto;box-shadow:0 0 10px rgba(0,255,0,0.3);">
    <div style="display:flex;justify-content:space-between;margin-bottom:8px;border-bottom:1px solid #0f0;padding-bottom:8px;">
      <strong>ğŸ”§ WebRTC è¨ºæ–·</strong>
      <button id="closeDiagBtn" style="background:#0f0;color:#1a1a1a;border:none;padding:2px 6px;cursor:pointer;font-weight:bold;">é—œ</button>
    </div>
    <div id="diagContent" style="line-height:1.6;">
      <div>é€£ç·šç‹€æ…‹ï¼š<span id="connStatus">---</span></div>
      <div>ICE ç‹€æ…‹ï¼š<span id="iceStatus">---</span></div>
      <div>ç°½ç½²ç‹€æ…‹ï¼š<span id="sigStatus">---</span></div>
      <div>å·²ç™¼é€å€™é¸ï¼š<span id="candCount">0</span> <span style="color:#888;">(Host/Srflx/Relay)</span></div>
      <div style="margin-top:6px;padding-top:6px;border-top:1px solid #333;">
        <div style="color:#888;font-size:10px;">Relay å€™é¸ï¼š<span id="relayCands">âŒ æœªç™¼ç¾</span></div>
        <div style="color:#888;font-size:10px;">TURN ä¼ºæœå™¨ï¼š<span id="turnServer">---</span></div>
      </div>
    </div>
  </div>

  <div style="text-align:center;margin-top:10px;">
    <input type="file" id="coverUpload" accept="image/*">
    <button id="uploadBtn">ğŸ“· ä¸Šå‚³å°é¢</button>
    <div style="margin-top:8px;">
      <input id="pkTarget" placeholder="è¼¸å…¥å°æ–¹æˆ¿é–“è™Ÿç™¼èµ· PK" style="padding:6px;border-radius:4px;border:1px solid #ccc;">
      <button id="pkSendBtn" style="margin-left:6px;padding:6px 8px;">ç™¼èµ· PK</button>
      <label style="margin-left:12px;display:inline-flex;align-items:center;gap:6px;">
        <input type="checkbox" id="pkAcceptToggle" checked> æ¥å— PK
      </label>
    </div>
  </div>


  <!-- ç›´æ’­ç•«é¢èˆ‡èŠå¤©å®¤ -->
  <div class="viewer-layout">
    <div class="viewer-area">
      <video id="video" autoplay muted playsinline></video>
    </div>
    
    <!-- chat for broadcaster -->
    <aside class="chat-area">
      <div id="chatContainer">
        <div id="messages"></div>
        <div class="chat-input-row">
          <input id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯...">
          <button id="sendBtn" disabled>é€å‡º</button>
        </div>
      </div>
    </aside>
  </div>
  <button id="endBtn" style="background:#c00;color:#fff;border:none;padding:10px 16px;border-radius:6px;margin-top:10px;">
  ğŸ›‘ çµæŸç›´æ’­
  </button>

  <!-- === Reactions / Emoji åŒºåŸŸï¼ˆæ¢å¾©é PK ç›´æ’­çš„äº’å‹•ï¼‰ === -->
  <div id="reactionBar" style="margin:14px auto 4px;max-width:720px;text-align:center;display:flex;justify-content:center;gap:10px;flex-wrap:wrap;">
    <button class="react-btn" data-type="heart" title="é€å‡º ğŸ’–">ğŸ’–</button>
    <button class="react-btn" data-type="laugh" title="é€å‡º ğŸ˜„">ğŸ˜„</button>
    <button class="react-btn" data-type="cry" title="é€å‡º ğŸ˜¢">ğŸ˜¢</button>
    <button class="react-btn" data-type="like" title="é€å‡º ğŸ‘">ğŸ‘</button>
    <button id="reactionValve" style="padding:8px 12px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:14px;cursor:pointer;">ğŸ” å‹•ç•«: é–‹å•Ÿ</button>
    <button id="reactionReselect" style="padding:8px 12px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:14px;cursor:pointer;">ğŸ¯ é‡é¸è¡¨æƒ…</button>
  </div>
  <div id="reactionLayer" style="position:fixed; right:18px; bottom:90px; width:180px; height:55vh; pointer-events:none; overflow:visible; z-index:9999; display:flex; flex-direction:column; align-items:flex-end; gap:6px;"></div>
  <style>
    .react-btn { width:58px;height:58px;border-radius:50%;border:none;font-size:26px;cursor:pointer;background:linear-gradient(145deg,#222,#111);color:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.4);transition:transform .15s, box-shadow .15s; }
    .react-btn:hover { transform:translateY(-3px) scale(1.06); box-shadow:0 8px 18px rgba(0,0,0,0.55); }
    .react-btn:disabled { filter:grayscale(70%); opacity:.55; cursor:not-allowed; }
    #reactionValve.off { background:#300; color:#f88; }
    .emoji-particle { position:fixed; font-size:22px; opacity:0; transform:translate3d(0,0,0) scale(.9); transition:transform 1.15s cubic-bezier(.2,.9,.2,1), opacity 1.15s linear; will-change:transform,opacity; pointer-events:none; }
  </style>

  <script src="/socket.io/socket.io.js"></script>
  <script src="filters.js"></script>
  <script>
    
    // è¨ºæ–·é¢æ¿æ›´æ–°å‡½æ•¸
    function updateDiagPanel(pc, candCount, hasRelay, relayServer) {
      document.getElementById('connStatus').textContent = pc?.connectionState || '---';
      document.getElementById('iceStatus').textContent = pc?.iceConnectionState || '---';
      document.getElementById('sigStatus').textContent = pc?.signalingState || '---';
      
      const totalCands = (candCount.host || 0) + (candCount.srflx || 0) + (candCount.relay || 0);
      document.getElementById('candCount').textContent = `${totalCands} (${candCount.host || 0}H/${candCount.srflx || 0}S/${candCount.relay || 0}R)`;
      
      if (hasRelay) {
        document.getElementById('relayCands').innerHTML = `âœ… å·²ç™¼ç¾ (${relayServer || 'æœªçŸ¥'})`;
        document.getElementById('relayCands').style.color = '#00ff00';
      } else {
        document.getElementById('relayCands').innerHTML = 'âŒ æœªç™¼ç¾';
        document.getElementById('relayCands').style.color = '#ff6b6b';
      }
    }

    // è¨ºæ–·é¢æ¿é–‹é—œ
    document.getElementById('diagBtn').addEventListener('click', () => {
      const panel = document.getElementById('diagPanel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    });
    
    document.getElementById('closeDiagBtn')?.addEventListener('click', () => {
      document.getElementById('diagPanel').style.display = 'none';
    });

    const socket = io();
    const peerConnections = {};
    const config = { 
      iceServers: [
        { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302", "stun:stun2.l.google.com:19302", "stun:stun3.l.google.com:19302", "stun:stun4.l.google.com:19302"] },
        {
          urls: ["turn:turnserver.open-telekom.de:3478", "turn:turnserver.open-telekom.de:3478?transport=tcp"],
          username: "webrtc",
          credential: "webrtcpassword"
        },
        {
          urls: ["turn:openrelay.metered.ca:80", "turn:openrelay.metered.ca:443", "turn:openrelay.metered.ca:443?transport=tcp"],
          username: "openrelayproject",
          credential: "openrelayproject"
        },
        {
          urls: ["turn:relay.metered.ca:80", "turn:relay.metered.ca:443"],
          username: "4f15fe3c0b2872b6dedb8d4d",
          credential: "2N8yzKQT6uHLiKM2"
        }
      ],
      iceCandidatePoolSize: 20,
      iceTransportPolicy: "all"
    };
    const video = document.getElementById("video");

    const params = new URLSearchParams(window.location.search);
    const roomId = params.get("room");

    // é©—è­‰æ˜¯å¦ç‚ºæˆ¿ä¸»
    fetch(`/api/verify-broadcaster?room=${roomId}`, { credentials: 'include' })
      .then(res => res.json())
      .then(result => {
        if (!result.valid) {
          document.body.innerHTML = `
            <div style="text-align:center;margin-top:100px;">
              <h1>âŒ 404 Not Found</h1>
              <p>${result.reason || 'ç„¡æ•ˆæˆ¿é–“'}</p>
              <p>3 ç§’å¾Œè¿”å›é¦–é ...</p>
            </div>`;
          setTimeout(() => (window.location.href = '/index.html'), 3000);
          throw new Error("Unauthorized");
        }
      })
      .catch(() => {});

    document.getElementById("roomCode").textContent = roomId;

    // join chat room as host (ä½†ä¸è¦ç«‹å³ broadcaster-joinï¼Œç­‰ getUserMedia æˆåŠŸ)
    socket.emit('join-room', roomId);
    // throttle viewer count UI updates to avoid rapid DOM churn (max once per 2s)
    let _lastViewerUpdate = 0;
    let _pendingViewerCount = null;
    function _applyViewerCount(count) {
      const el = document.getElementById('viewerCount');
      if (!el) return;
      el.textContent = count;
    }
    function updateViewerCountThrottled(count) {
      const now = Date.now();
      const el = document.getElementById('viewerCount');
      if (!el) return;
      const gap = 2000; // ms
      if (now - _lastViewerUpdate >= gap) {
        _applyViewerCount(count);
        _lastViewerUpdate = now;
      } else {
        _pendingViewerCount = count;
        if (!updateViewerCountThrottled._timer) {
          const wait = gap - (now - _lastViewerUpdate);
          updateViewerCountThrottled._timer = setTimeout(() => {
            _applyViewerCount(_pendingViewerCount);
            _lastViewerUpdate = Date.now();
            _pendingViewerCount = null;
            updateViewerCountThrottled._timer = null;
          }, wait);
        }
      }
    }
    socket.on("viewer-count", count => {
      updateViewerCountThrottled(count);
    });

    // update top reaction UI when server pushes stats
    socket.on('reaction-stats', stats => {
      const el = document.getElementById('topReaction');
      if (!el) return;
      if (!stats || !stats.topType) {
        el.textContent = '';
        return;
      }
      const emojiMap = { heart: 'ğŸ’–', laugh: 'ğŸ˜„', cry: 'ğŸ˜¢', like: 'ğŸ‘' };
      const e = emojiMap[stats.topType] || stats.topType;
      el.textContent = `${e} ${stats.topCount}`;
    });

    // === æ™®é€šç›´æ’­çš„ Reactions åŠŸèƒ½ï¼ˆåƒ…ç¬¬ä¸€æ¬¡é»æ“Šè¨ˆå…¥çµ±è¨ˆï¼›Valve æ§åˆ¶æœ¬åœ°ç²’å­å‹•ç•«ï¼‰ ===
  let showEmoji = true;           // é–¥é–€ï¼šæ˜¯å¦é¡¯ç¤ºæœ¬åœ°å‹•ç•«
  let reacted = false;            // æ˜¯å¦å·²é€å‡ºéç¬¬ä¸€æ¬¡åæ‡‰ï¼ˆçµ±è¨ˆåªè¨˜ç¬¬ä¸€å€‹ï¼‰
  const valveBtn = document.getElementById('reactionValve');
  const reselectBtn = document.getElementById('reactionReselect');
  let reselectMode = false;       // é‡é¸æ¨¡å¼ï¼šä¸‹ä¸€æ¬¡é»æ“Šè¡¨æƒ…åŸ·è¡Œ reaction-change

    function spawnEmoji(type, opts = {}) {
      if (!showEmoji) return; // é–¥é–€é—œé–‰æ™‚ä¸é¡¯ç¤ºï¼Œä½†ä»å¯çµ±è¨ˆ
      const layer = document.getElementById('reactionLayer');
      if (!layer) return;
      const el = document.createElement('div');
      el.className = 'emoji-particle';
      el.textContent = (type === 'heart') ? 'ğŸ’–' : (type === 'laugh') ? 'ğŸ˜„' : (type === 'cry') ? 'ğŸ˜¢' : 'ğŸ‘';
      // å‡ºç¾ä½ç½®ï¼šå½±ç‰‡å³ä¸‹é™„è¿‘æµ®èµ·
      const ref = document.getElementById('video');
      let startX, startY;
      if (ref && typeof ref.getBoundingClientRect === 'function') {
        const r = ref.getBoundingClientRect();
        startX = r.right - 40 + (Math.random() - 0.5) * 32;
        startY = r.bottom - 30 + (Math.random() - 0.5) * 18;
      } else {
        startX = window.innerWidth * 0.75 + (Math.random() - 0.5) * 120;
        startY = window.innerHeight * 0.6 + (Math.random() - 0.5) * 100;
      }
      el.style.left = startX + 'px';
      el.style.top = startY + 'px';
      el.style.fontSize = (opts.size || (18 + Math.random() * 18)) + 'px';
      el.style.opacity = '1';
      layer.appendChild(el);
      requestAnimationFrame(() => {
        const dx = (Math.random() - 0.5) * 55;
        const dy = - (200 + Math.random() * 150);
        const rot = (Math.random() - 0.5) * 40;
        el.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) scale(1.05)`;
        el.style.opacity = '0';
      });
      setTimeout(() => { try { el.remove(); } catch (e) {} }, 1200);
    }

    // é»æ“Š Valve åˆ‡æ›å‹•ç•«é¡¯ç¤ºç‹€æ…‹
    if (valveBtn) {
      valveBtn.addEventListener('click', () => {
        showEmoji = !showEmoji;
        valveBtn.classList.toggle('off', !showEmoji);
        valveBtn.textContent = showEmoji ? 'ğŸ” å‹•ç•«: é–‹å•Ÿ' : 'ğŸ” å‹•ç•«: é—œé–‰';
      });
    }

    if (reselectBtn) {
      reselectBtn.addEventListener('click', () => {
        reselectMode = true;
        reselectBtn.textContent = 'ğŸ¯ é‡é¸ä¸­â€¦';
        reselectBtn.disabled = true;
        setTimeout(() => { if (reselectMode) { reselectMode = false; reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; } }, 5000);
      });
    }

    // ç›£è½ä¾†è‡ªå…¶ä»–ä½¿ç”¨è€…çš„ reaction äº‹ä»¶ â†’ é¡¯ç¤ºå‹•ç•«ï¼ˆä¸å½±éŸ¿çµ±è¨ˆï¼‰
    socket.on('reaction', ({ type, from }) => {
      try { spawnEmoji(type); } catch (e) {}
    });

    // ç¶å®šæŒ‰éˆ•é€å‡º reactionï¼šæ¯æ¬¡éƒ½é€äº‹ä»¶ä»¥é¡¯ç¤ºå‹•ç•«ï¼›çµ±è¨ˆåƒ…è¨˜ç¬¬ä¸€æ¬¡
    document.querySelectorAll('.react-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.type;
        if (!roomId || !type) return;
        // æ¯æ¬¡éƒ½é€å‡ºäº‹ä»¶ï¼ˆå‹•ç•«å¯è¦‹ï¼‰ï¼›è‹¥åœ¨é‡é¸æ¨¡å¼å‰‡ç™¼é€ reaction-change
        if (reselectMode) {
          socket.emit('reaction-change', { roomId, type });
          reselectMode = false;
          if (reselectBtn) { reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; }
        } else {
          socket.emit('reaction', { roomId, type });
          if (!reacted) reacted = true;
        }
        spawnEmoji(type, { size: 22 + Math.random() * 16 });
      });
    });

    // PK UI handlers
    const pkSendBtn = document.getElementById('pkSendBtn');
    const pkTargetInput = document.getElementById('pkTarget');
    const pkToggle = document.getElementById('pkAcceptToggle');

    pkToggle.addEventListener('change', () => {
      socket.emit('pk-toggle', { roomId, enabled: pkToggle.checked });
    });

    pkSendBtn.onclick = () => {
      const target = (pkTargetInput.value || '').trim();
      if (!target) return alert('è«‹è¼¸å…¥ç›®æ¨™æˆ¿é–“è™Ÿ');
      socket.emit('pk-request', { fromRoom: roomId, targetRoom: target });
      // show pending panel
      showPkPending(target);
      pkSendBtn.disabled = true;
      setTimeout(() => { pkSendBtn.disabled = false; }, 3000);
    };

    // incoming PK invite
    socket.on('pk-invite', ({ fromRoom, fromSocket }) => {
      // show a non-blocking modal dialog so it appears even if page didn't get recent user focus
      try {
        // avoid creating multiple modals
        if (document.getElementById('__pk_invite_modal')) return;
        const modal = document.createElement('div');
        modal.id = '__pk_invite_modal';
        modal.style.position = 'fixed';
        modal.style.left = '50%';
        modal.style.top = '40%';
        modal.style.transform = 'translate(-50%, -50%)';
        modal.style.background = '#fff';
        modal.style.color = '#000';
        modal.style.padding = '14px';
        modal.style.borderRadius = '8px';
        modal.style.boxShadow = '0 8px 24px rgba(0,0,0,0.3)';
        modal.style.zIndex = 20000;
        modal.innerHTML = `<div style="font-weight:600;margin-bottom:8px;">æˆ¿é–“ ${fromRoom} é‚€è«‹æ‚¨ PK</div>
          <div style="margin-bottom:10px;">æ˜¯å¦æ¥å—å°æ–¹æŒ‘æˆ°ï¼Œæ¯”æ¯”äººæ°£ï¼Ÿ</div>
          <div style="text-align:right;display:flex;gap:8px;justify-content:flex-end;">
            <button id="__pk_reject" style="padding:6px 10px;border-radius:6px;">æ‹’çµ•</button>
            <button id="__pk_accept" style="padding:6px 10px;border-radius:6px;background:#2196F3;color:#fff;border:none;">æ¥å—</button>
          </div>`;
        document.body.appendChild(modal);
        const clean = () => { try { modal.remove(); } catch (e) {} };
        document.getElementById('__pk_accept').onclick = () => { socket.emit('pk-response', { fromRoom, targetRoom: roomId, accept: true }); clean(); };
        document.getElementById('__pk_reject').onclick = () => { socket.emit('pk-response', { fromRoom, targetRoom: roomId, accept: false }); clean(); };
        // auto-dismiss after 20s
        setTimeout(() => { try { if (document.getElementById('__pk_invite_modal')) clean(); } catch (e) {} }, 20000);
      } catch (e) {
        // if modal creation fails, auto-decline and notify requester
        try { socket.emit('pk-response', { fromRoom, targetRoom: roomId, accept: false }); } catch (ee) {}
      }
    });

    // show a small pending panel for the PK requester
    function showPkPending(targetRoom) {
      // remove existing
      const existing = document.getElementById('__pk_pending');
      if (existing) existing.remove();
      const p = document.createElement('div');
      p.id = '__pk_pending';
      p.style.position = 'fixed';
      p.style.right = '12px';
      p.style.top = '12px';
      p.style.zIndex = 20000;
      p.style.background = 'rgba(0,0,0,0.75)';
      p.style.color = '#fff';
      p.style.padding = '8px 10px';
      p.style.borderRadius = '8px';
      p.style.boxShadow = '0 6px 18px rgba(0,0,0,0.4)';
      p.innerHTML = `<div style="display:flex;gap:8px;align-items:center;"><div>å·²å‘ ${targetRoom} ç™¼é€ PK é‚€è«‹ï¼Œç­‰å¾…å›è¦†â€¦</div><button id="__pk_cancel" style="margin-left:8px;padding:6px;border-radius:6px;">å–æ¶ˆ</button></div>`;
      document.body.appendChild(p);
      document.getElementById('__pk_cancel').onclick = () => {
        try { p.remove(); } catch (e) {}
        try { socket.emit('pk-response', { fromRoom: roomId, targetRoom: targetRoom, accept: false, cancelled: true }); } catch (e) {}
      };
      // auto-dismiss after 20s (if still there)
      setTimeout(() => { try { if (document.getElementById('__pk_pending')) document.getElementById('__pk_pending').remove(); } catch (e) {} }, 20000);
    }

    // handle pk-response sent back to the requester
    socket.on('pk-response', ({ fromRoom, targetRoom, accept, responderSocket }) => {
      try {
        // if this client is the one who initiated (roomId === fromRoom)
        if (roomId === fromRoom) {
          const el = document.getElementById('__pk_pending');
          if (el) el.remove();
          const toast = document.createElement('div');
          toast.style.position = 'fixed';
          toast.style.right = '12px';
          toast.style.top = '12px';
          toast.style.zIndex = 20001;
          toast.style.background = accept ? 'linear-gradient(90deg,#4caf50,#66bb6a)' : 'linear-gradient(90deg,#f44336,#ef5350)';
          toast.style.color = '#fff';
          toast.style.padding = '8px 12px';
          toast.style.borderRadius = '8px';
          toast.style.boxShadow = '0 6px 18px rgba(0,0,0,0.4)';
          toast.textContent = accept ? 'å°æ–¹å·²æ¥å— PKï¼Œæ­£åœ¨æº–å‚™...' : 'å°æ–¹å·²æ‹’çµ• PK';
          document.body.appendChild(toast);
          setTimeout(() => { try { toast.remove(); } catch (e) {} }, 4000);
        }
      } catch (e) {}
    });

    // handle pk-start: both broadcasters should redirect to PK page
    socket.on('pk-start', ({ combinedRoom, leftOwner, rightOwner }) => {
      // navigate to pk-broadcaster page; include left/right owner ids so page knows which side is which
      try {
        const qs = new URLSearchParams({ room: combinedRoom });
        if (leftOwner) qs.set('leftOwner', String(leftOwner));
        if (rightOwner) qs.set('rightOwner', String(rightOwner));
        window.location.href = `/pk-broadcaster.html?${qs.toString()}`;
      } catch (e) {
        // fallback
        window.location.href = `/pk-broadcaster.html?room=${encodeURIComponent(combinedRoom)}`;
      }
    });

    // if viewers in this room need to be merged, server emits pk-merged (handled by viewers)

    // broadcaster spawn emoji helper removed from non-PK page (moved to PK page)

    // åˆ†äº«åŠŸèƒ½
    document.getElementById("shareBtn").onclick = () => {
      const shareUrl = `${window.location.origin}/viewer.html?room=${roomId}`;
      navigator.clipboard.writeText(shareUrl);
      alert(`ğŸ“ å·²è¤‡è£½åˆ†äº«é€£çµï¼š\n${shareUrl}`);
    };

    // å•Ÿå‹•æ”å½±æ©Ÿèˆ‡éº¥å…‹é¢¨
    navigator.mediaDevices.getUserMedia({ video: true, audio: true })
      .then(async stream => {
  // camera opened

        // Debug: log audio tracks availability
        try {
          const audios = stream.getAudioTracks();
          console.log('[Broadcaster] audio tracks:', audios.length, audios.map(a => ({ label: a.label, enabled: a.enabled, muted: a.muted })));
        } catch (e) { console.warn('[Broadcaster] cannot inspect audio tracks', e); }

        // Create a hidden source video element that plays the raw camera stream.
        // FilterManager needs a video element that contains the RAW frames to draw into canvas.
        const sourceVideo = document.createElement('video');
        sourceVideo.autoplay = true;
        sourceVideo.muted = true;
        sourceVideo.playsInline = true;
        sourceVideo.style.display = 'none';
        document.body.appendChild(sourceVideo);
        sourceVideo.srcObject = stream;
        // Don't call sourceVideo.play() here â€” MediaPipe Camera (if used) may re-load the video
        // which can abort an in-progress play() request and cause an AbortError. Let the
        // Camera helper manage playback timing. If you need an explicit play, call it
        // after Camera is started or handle AbortError specifically.

    // å»ºç«‹ FilterManagerï¼šå°‡åŸå§‹æ”å½±æ©Ÿæµä½œç‚ºä¾†æºï¼Œç”¢ç”Ÿè™•ç†å¾Œçš„è¦–è¨Šï¼ˆcanvasï¼‰
    // ä½¿ç”¨æ‰‹æ©Ÿç›¸å®¹æ€§ä¿®å¾©å–å¾—æœ€ä½³åŒ–é…ç½®
    const filterConfig = window.MobileFix ? window.MobileFix.getMobileOptimizedConfig() : { width: 1280, height: 720, fps: 25, autoFace: true };
    console.log('[Broadcaster] ä½¿ç”¨æ¿¾é¡é…ç½®:', filterConfig);
    const filterMgr = new FilterManager(sourceVideo, stream, filterConfig);

        // preview broadcaster: é¡¯ç¤ºè™•ç†å¾Œçš„è¦–è¨Šï¼ˆcanvas streamï¼‰
        const processedStream = filterMgr.getProcessedStream();
        const previewStream = new MediaStream();

        // helper: wait for processedStream to expose a video track (polling)
        const waitForProcessedVideo = async (timeout = 5000) => {
          const start = Date.now();
          while (Date.now() - start < timeout) {
            const t = processedStream.getVideoTracks();
            if (t && t.length) return t[0];
            await new Promise(r => setTimeout(r, 100));
          }
          return null;
        };

        const initialTrack = await waitForProcessedVideo(5000);
        if (initialTrack) previewStream.addTrack(initialTrack);
        else console.warn('processed video track not ready');

        // show preview (processed)
        video.srcObject = previewStream;
        video.play().catch(()=>{});

        // announce broadcaster: åŠ å…¥æˆ¿é–“ä¸¦åœ¨æˆ¿é–“å…§å»£æ’­
        socket.emit('broadcaster-join', roomId);
        socket.emit("broadcaster", roomId);
        // å†æ¬¡å»£æ’­ä»¥ç¢ºä¿å·²é€£ç·šçš„ viewer æ”¶åˆ°é€šçŸ¥
        setTimeout(() => socket.emit("broadcaster", roomId), 500);

        // ç›£è½èˆŠçš„ watcher äº‹ä»¶ä¿æŒç›¸å®¹æ€§
        socket.on("watcher", async id => {
          console.log('[Broadcaster] watcher event (legacy)', id);
          await createPeerConnection(id);
        });

        // ç›£è½æ–°çš„ viewer-ready äº‹ä»¶ï¼šç•¶è§€çœ¾åŠ å…¥æˆ¿é–“æ™‚ä¸»å‹•å»ºç«‹é€£ç·š
        socket.on('viewer-ready', async ({ viewerId }) => {
          console.log('[Broadcaster] viewer-ready event, creating connection for', viewerId);
          await createPeerConnection(viewerId);
        });

        // çµ±ä¸€çš„å»ºç«‹ peer connection å‡½æ•¸
        async function createPeerConnection(id) {
          if (!id || id === 'undefined') {
            console.error('[Broadcaster] âŒ invalid viewer id:', id);
            return;
          }
          
          // é¿å…é‡è¤‡å»ºç«‹é€£ç·š
          if (peerConnections[id]) {
            console.log('[Broadcaster] âš ï¸ peer connection already exists for', id, '- skipping');
            return;
          }
          
          console.log('[Broadcaster] creating peer connection for', id);
          const pc = new RTCPeerConnection(config);
          peerConnections[id] = pc;

          // è¨ºæ–·ç‹€æ…‹è¿½è¹¤
          let iceCandidateCount = { host: 0, srflx: 0, relay: 0 };
          let hasRelay = false;
          let relayServer = null;

          pc.onicecandidate = event => {
            if (event.candidate) {
              const cand = event.candidate;
              const type = cand.type; // host, srflx, relay
              const addr = cand.address || 'unknown';
              const proto = cand.protocol || 'unknown';
              console.log(`[Broadcaster] ğŸ“¡ ICE candidate (${type}): ${proto} ${addr}:${cand.port}`);
              
              // è¿½è¹¤å€™é¸é¡å‹
              if (iceCandidateCount[type] !== undefined) iceCandidateCount[type]++;
              if (type === 'relay') {
                hasRelay = true;
                relayServer = cand.relatedAddress || addr;
              }
              
              // æ›´æ–°é é¢è¨ºæ–·
              updateDiagPanel(pc, iceCandidateCount, hasRelay, relayServer);
              
              socket.emit("candidate", id, event.candidate);
            } else {
              console.log(`[Broadcaster] âœ… ICE gathering complete for ${id}`);
            }
          };

          // ç›£è½é€£ç·šç‹€æ…‹è®ŠåŒ–
          pc.onconnectionstatechange = () => {
            console.log(`[Broadcaster] ğŸ”— connection state: ${pc.connectionState}`);
            updateDiagPanel(pc, iceCandidateCount, hasRelay, relayServer);
          };

          pc.oniceconnectionstatechange = () => {
            console.log(`[Broadcaster] ğŸ§Š ICE connection state: ${pc.iceConnectionState}`);
            updateDiagPanel(pc, iceCandidateCount, hasRelay, relayServer);
          };

          pc.onsignalingstatechange = () => {
            console.log(`[Broadcaster] ğŸ“¢ signaling state: ${pc.signalingState}`);
            updateDiagPanel(pc, iceCandidateCount, hasRelay, relayServer);
          };

          // å‰µå»ºä¸€å€‹çµ±ä¸€çš„ MediaStream åŒ…å«éŸ³è¨Šå’Œè¦–è¨Š
          const combinedStream = new MediaStream();
          
          // add original audio tracks from camera FIRST
          const audios = stream.getAudioTracks();
          console.log('[Broadcaster] preparing to add audio tracks, count:', audios ? audios.length : 0);
          if (!audios || !audios.length) {
            console.error('[Broadcaster] âŒâŒ NO audio tracks available to send! stream:', stream, 'tracks:', stream ? stream.getTracks() : null);
          } else {
            audios.forEach(a => {
              console.log('[Broadcaster] âœ“ adding audio track:', a.label, 'enabled:', a.enabled, 'muted:', a.muted, 'readyState:', a.readyState);
              combinedStream.addTrack(a); // æ·»åŠ åˆ°çµ±ä¸€ stream
              const sender = pc.addTrack(a, combinedStream); // ä½¿ç”¨çµ±ä¸€ stream
              console.log('[Broadcaster] âœ“ audio sender created:', {
                track: { id: a.id, enabled: a.enabled, muted: a.muted, readyState: a.readyState },
                senderParams: sender.getParameters?.()
              });
            });
          }
          
          // è¨ºæ–·ï¼šæª¢æŸ¥ç•¶å‰çš„ senders å’Œè»Œé“
          const sendersAfterAudio = pc.getSenders();
          console.log('[Broadcaster] ğŸ“‹ After adding audio - Total senders:', sendersAfterAudio.length);
          sendersAfterAudio.forEach((s, i) => {
            console.log(`[Broadcaster]   sender[${i}]: kind=${s.track?.kind}, enabled=${s.track?.enabled}, readyState=${s.track?.readyState}`);
          });

          // then add video track
          console.log('[Broadcaster] ğŸ¥ preparing to add video track...');
          console.log('[Broadcaster] ğŸ“Š processedStream tracks:', processedStream ? processedStream.getTracks().map(t => ({ kind: t.kind, label: t.label, enabled: t.enabled, readyState: t.readyState })) : 'null');
          
          let currentProcessed = processedStream.getVideoTracks()[0];
          
          // helper: wait briefly for processedStream to expose a video track
          const waitForTrack = async (timeout = 3000) => {
            const start = Date.now();
            while (Date.now() - start < timeout) {
              const t = processedStream.getVideoTracks();
              if (t && t.length) return t[0];
              await new Promise(r => setTimeout(r, 100));
            }
            return null;
          };

          // try immediate, else wait a short time
          if (!currentProcessed) {
            console.log('[Broadcaster] â³ waiting for processed video track...');
            currentProcessed = await waitForTrack(3000);
          }
          
          if (currentProcessed) {
            try { 
              console.log('[Broadcaster] ğŸ¥ adding video track:', currentProcessed.label, 'enabled:', currentProcessed.enabled, 'readyState:', currentProcessed.readyState);
              combinedStream.addTrack(currentProcessed); // æ·»åŠ åˆ°çµ±ä¸€ stream
              const sender = pc.addTrack(currentProcessed, combinedStream); // ä½¿ç”¨çµ±ä¸€ stream
              console.log('[Broadcaster] âœ… video track added successfully, sender:', sender);
              console.log('[Broadcaster] ğŸ“¦ combinedStream final tracks:', combinedStream.getTracks().map(t => ({ kind: t.kind, label: t.label })));
            } catch (e) { 
              console.error('[Broadcaster] âŒ failed to add video track:', e); 
            }
          } else {
            console.error('[Broadcaster] âŒâŒ NO processed video track available for viewer', id);
            console.error('[Broadcaster] ğŸ” processedStream state:', {
              stream: processedStream,
              tracks: processedStream ? processedStream.getTracks() : null,
              videoTracks: processedStream ? processedStream.getVideoTracks() : null,
              active: processedStream ? processedStream.active : null
            });
          }

          // æœ€çµ‚è¨ºæ–·ï¼šæª¢æŸ¥æ‰€æœ‰å·²æ·»åŠ çš„ senders
          const allSenders = pc.getSenders();
          console.log('[Broadcaster] ğŸ“‹ FINAL RTCRtpSenders before offer:', allSenders.length);
          allSenders.forEach((sender, i) => {
            const track = sender.track;
            if (track) {
              console.log(`[Broadcaster]   [${i}] ${track.kind}: id=${track.id}, enabled=${track.enabled}, readyState=${track.readyState}, muted=${track.muted}`);
            } else {
              console.warn(`[Broadcaster]   [${i}] NO TRACK (sender exists but track is null)`);
            }
          });
          
          // create and send offer
          try {
            console.log('[Broadcaster] creating offer for', id);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            console.log('[Broadcaster] sending offer to', id);
            socket.emit('offer', id, pc.localDescription);
          } catch (e) {
            console.error('[Broadcaster] âŒ failed to create/send offer to', id, e);
          }
        }

        socket.on("answer", (id, description) => {
          console.log('[Broadcaster] â¬‡ï¸ received answer from', id);
          if (peerConnections[id]) {
            peerConnections[id].setRemoteDescription(description).then(() => {
              console.log('[Broadcaster] âœ“ set remote description from answer');
            }).catch(err => {
              console.error('[Broadcaster] âŒ failed to set remote description:', err);
            });
          } else {
            console.warn('[Broadcaster] âš ï¸ received answer but no peer connection for', id);
          }
        });
        
        socket.on("candidate", (id, candidate) => {
          console.log('[Broadcaster] adding ICE candidate from viewer', id);
          if (peerConnections[id]) {
            peerConnections[id].addIceCandidate(new RTCIceCandidate(candidate)).catch(err => {
              console.warn('[Broadcaster] failed to add ICE candidate:', err);
            });
          }
        });
        
        socket.on("bye", id => {
          console.log('[Broadcaster] viewer disconnected:', id);
          if (peerConnections[id]) {
            peerConnections[id].close();
            delete peerConnections[id];
          }
        });
      })
      .catch(err => {
        console.error("ğŸš« é¡é ­é–‹å•Ÿå¤±æ•—ï¼š", err);
        alert("è«‹å…è¨±ç›¸æ©Ÿèˆ‡éº¥å…‹é¢¨æ¬Šé™ï¼Œå¦å‰‡ç„¡æ³•é–‹æ’­ã€‚");
      });

      // === æ¯ 10 ç§’é€å¿ƒè·³ ===
    setInterval(() => {
      fetch('/api/heartbeat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ roomId })
      });
    }, 10000);

    // === çµæŸç›´æ’­ ===
    document.getElementById('endBtn').onclick = async () => {
      if (confirm("ç¢ºå®šè¦çµæŸç›´æ’­å—ï¼Ÿ")) {
        await fetch('/api/end-stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ roomId })
        });

        // é—œé–‰æ”å½±æ©Ÿ
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.stop());
        }

        alert("ç›´æ’­å·²çµæŸï¼");
        window.location.href = '/index.html';
      }
    };

    // ä¸Šå‚³å°é¢
    document.getElementById('uploadBtn').onclick = async () => {
      const fileInput = document.getElementById('coverUpload');
      if (!fileInput.files.length) return alert("è«‹é¸æ“‡åœ–ç‰‡");
      if (!roomId) return alert("âš ï¸ éŒ¯èª¤ï¼šæˆ¿é–“è™Ÿæœªå®šç¾©ï¼Œè«‹é‡æ–°æ•´ç†é é¢ã€‚");

  const formData = new FormData();
  // IMPORTANT: append roomId first so multer can read it when handling the file
  formData.append('roomId', roomId); // âœ… é—œéµï¼šä¸€å®šè¦å‚³æˆ¿é–“è™Ÿï¼
  formData.append('cover', fileInput.files[0]);

      try {
        const res = await fetch('/api/upload-cover', {
          method: 'POST',
          credentials: 'include',
          body: formData
        });
        const data = await res.json();
        alert(data.message);
      } catch (err) {
        console.error("âŒ ä¸Šå‚³å¤±æ•—ï¼š", err);
      }
    };

    // --- broadcaster chat logic ---
    const sendBtn = document.getElementById('sendBtn');
  let hostName = 'ä¸»æ’­';  // ç§»é™¤ (HOST) å‰ç¶´ï¼Œæ”¹ç”¨è¡¨æƒ…ç¬¦è™Ÿ
  let hostAvatar = '/uploads/default_avatar.png';
  let hostId = null; // broadcaster user id for chat color

    // get broadcaster profile
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) {
          hostName = data.username;  // ä¸åŠ  (HOST) å‰ç¶´
          hostAvatar = data.avatar || hostAvatar;
          hostId = data.id || null;
        }
      })
      .catch(() => {})
      .finally(() => { sendBtn.disabled = false; });

    // deterministic pastel-ish color generator based on userId (or username fallback)
    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
      const idForColor = data.userId || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar">
                      <div class="text"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // å‚³é€è¨Šæ¯åŠŸèƒ½
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId, user: hostName, userId: hostId, text, avatar: hostAvatar, isHost: true });
      input.value = '';
    }

    // ç¶å®šé€å‡ºæŒ‰éˆ•
    document.getElementById('sendBtn').onclick = sendMessage;
    
    // ç¶å®š Enter éµ
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // é˜²æ­¢æ›è¡Œ
        sendMessage();
      }
    });



  </script>
</body>
</html>
