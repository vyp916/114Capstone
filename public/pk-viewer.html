<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>PK - Viewer</title>
  <link rel="stylesheet" href="style-modern.css">
  <style>
    .pk-container { display:flex; gap:12px; align-items:stretch; }
    .pk-side { flex:1; background:#111; color:#fff; border-radius:8px; padding:8px; }
    video { width:100%; height:calc(100vh - 180px); object-fit:cover; background:#000; border-radius:6px; }
    .pk-vote-btn {
      padding:8px 14px;
      border-radius:6px;
      border:none;
      color:#fff;
      font-weight:600;
      cursor:pointer;
      transition:transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s;
    }
    .pk-vote-btn.left { background:linear-gradient(90deg,#ff6b6b,#ff4081); box-shadow:0 8px 18px rgba(255,64,129,0.25); }
    .pk-vote-btn.right { background:linear-gradient(90deg,#42a5f5,#7c4dff); box-shadow:0 8px 18px rgba(124,77,255,0.25); }
    .pk-vote-btn.voted { opacity:0.85; transform:scale(0.97); }
    .pk-vote-btn:disabled { cursor:not-allowed; opacity:0.6; }
    .pk-react-btn {
      width:46px;
      height:46px;
      border-radius:50%;
      border:none;
      font-size:22px;
      cursor:pointer;
      background:rgba(255,255,255,0.08);
      color:#fff;
      transition:transform 0.15s ease, background 0.15s ease;
    }
    .pk-react-btn:hover { transform:translateY(-2px) scale(1.05); background:rgba(255,255,255,0.18); }
    .vote-burst {
      position:fixed;
      pointer-events:none;
      color:#fff;
      font-weight:700;
      text-shadow:0 0 8px rgba(255,255,255,0.6);
      opacity:0;
      transform:translate(-50%,0) scale(0.8);
      transition:opacity 0.4s ease, transform 0.4s ease;
      z-index:9999;
    }
    .vote-burst.show { opacity:1; transform:translate(-50%,-45px) scale(1.15); }
    .pk-toast {
      position:fixed;
      bottom:24px;
      left:50%;
      transform:translate(-50%,20px);
      background:rgba(0,0,0,0.78);
      color:#fff;
      padding:10px 18px;
      border-radius:999px;
      box-shadow:0 10px 25px rgba(0,0,0,0.35);
      font-weight:600;
      opacity:0;
      transition:opacity 0.2s ease, transform 0.2s ease;
      z-index:99999;
    }
    .pk-toast.show { opacity:1; transform:translate(-50%,0); }
  </style>
</head>
<body>
  <h2>PK è§€çœ‹ç•«é¢</h2>
  <div id="infoBar" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:6px;">
    <span>åˆä½µæˆ¿é–“ï¼š<strong id="roomCode">---</strong></span>
    <span>ğŸ‘¥ åœ¨ç·šäººæ•¸ï¼š<strong id="viewerCount">0</strong></span>
    <button id="shareBtn" style="padding:6px 10px;border-radius:6px;border:1px solid #444;background:#111;color:#eee;cursor:pointer;">ğŸ“¤ åˆ†äº«é€£çµ</button>
  </div>
  <div id="info">ç­‰å¾…å°å‘ä¸­â€¦</div>
  <div class="pk-container">
    <div class="pk-side">
      <h3>ä¸»æ’­ A</h3>
      <video id="videoA" autoplay playsinline controls></video>
    </div>
    <div class="pk-side">
      <h3>ä¸»æ’­ B</h3>
      <video id="videoB" autoplay playsinline controls></video>
    </div>
  </div>

  <!-- PK vote / heat UI -->
  <div style="display:flex; gap:12px; margin:12px 0; max-width:980px; margin-left:auto; margin-right:auto;">
    <div style="flex:1; text-align:center; color:#fff;">
      <div id="leftLabel">ä¸»æ’­ A</div>
      <div style="height:18px;background:rgba(255,255,255,0.06);border-radius:10px;margin:8px 12px;overflow:hidden;">
        <div id="leftHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#ff6b6b,#ff4081);"></div>
      </div>
  <button id="voteLeft" class="pk-vote-btn left">æ”¯æŒ ä¸»æ’­ A</button>
    </div>
    <div style="flex:1; text-align:center; color:#fff;">
      <div id="rightLabel">ä¸»æ’­ B</div>
      <div style="height:18px;background:rgba(255,255,255,0.06);border-radius:10px;margin:8px 12px;overflow:hidden;">
        <div id="rightHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#42a5f5,#7c4dff);"></div>
      </div>
    <button id="voteRight" class="pk-vote-btn right">æ”¯æŒ ä¸»æ’­ B</button>
    </div>
  </div>

  <!-- reaction buttons for PK viewer -->
  <div style="max-width:980px;margin:8px auto 0;display:flex;gap:8px;justify-content:center;">
    <button class="pk-react-btn" data-type="heart">ğŸ’–</button>
    <button class="pk-react-btn" data-type="laugh">ğŸ˜„</button>
    <button class="pk-react-btn" data-type="cry">ğŸ˜¢</button>
    <button class="pk-react-btn" data-type="like">ğŸ‘</button>
  </div>
  <div id="reactionLayer" style="position:fixed; right:20px; top:80px; left:20px; bottom:0; pointer-events:none; overflow:visible; z-index:9999;"></div>

  <!-- Chat area for PK viewer (same as regular viewer) -->
  <aside class="chat-area" style="width:100%; max-width:980px; margin:12px auto 0;">
    <div id="chatContainer" style="background:rgba(255,255,255,0.03); padding:10px; border-radius:8px;">
      <div id="messages" style="height:52vh; overflow:auto; margin-bottom:8px;"></div>
      <div class="chat-input-row" style="display:flex; gap:8px;">
        <input id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯..." style="flex:1; padding:8px; border-radius:6px; border:1px solid #444; background:transparent; color:#fff;">
        <button id="sendBtn" disabled style="padding:8px 10px; border-radius:6px;">é€å‡º</button>
      </div>
    </div>
  </aside>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const params = new URLSearchParams(window.location.search);
    const combinedRoom = params.get('room');
  // é¡¯ç¤ºæˆ¿é–“è™Ÿ
  try { const rc = document.getElementById('roomCode'); if (rc) rc.textContent = combinedRoom || '---'; } catch (e) {}
    const leftOwnerParam = params.get('left') || params.get('leftOwner') || null;
    const rightOwnerParam = params.get('right') || params.get('rightOwner') || null;
    const leftLabelEl = document.getElementById('leftLabel');
    const rightLabelEl = document.getElementById('rightLabel');
    const leftHeatEl = document.getElementById('leftHeat');
    const rightHeatEl = document.getElementById('rightHeat');
    const voteLeftBtn = document.getElementById('voteLeft');
    const voteRightBtn = document.getElementById('voteRight');
    let leftOwnerId = leftOwnerParam;
    let rightOwnerId = rightOwnerParam;
    let latestCounts = {};
    let toastTimer = null;
  // åˆå§‹æœªå–å¾—å·¦å³ä¸»æ’­ ID å‰ï¼Œå…ˆç¦ç”¨æŠ•ç¥¨æŒ‰éˆ•é¿å…èª¤è§¸
  if (voteLeftBtn) voteLeftBtn.disabled = true;
  if (voteRightBtn) voteRightBtn.disabled = true;

    if (!combinedRoom) {
      document.getElementById('info').textContent = 'éŒ¯èª¤ï¼šç¼ºå°‘åˆä½µæˆ¿é–“ç·¨è™Ÿ';
    } else {
      document.getElementById('info').textContent = `åˆä½µæˆ¿é–“ï¼š${combinedRoom}`;
      renderVoteUI();
      // join combined room as viewer - server will have emitted 'pk-merged' instructing redirect
      socket.emit('join-room', combinedRoom);
      // ask to receive streams: emit watcher so broadcasters create offers to this viewer
      socket.emit('watcher');
    }

    // åœ¨ç·šäººæ•¸æ›´æ–°ï¼ˆæ²¿ç”¨æœå‹™ç«¯ viewer-count äº‹ä»¶ï¼‰
    socket.on('viewer-count', count => {
      try { const vc = document.getElementById('viewerCount'); if (vc) vc.textContent = String(count); } catch (e) {}
    });

    // åˆ†äº«é€£çµ
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        const url = `${window.location.origin}/pk-viewer.html?room=${encodeURIComponent(combinedRoom || '')}`;
        navigator.clipboard.writeText(url).then(() => {
          alert(`ğŸ“ å·²è¤‡è£½åˆ†äº«é€£çµï¼š\n${url}`);
        }).catch(() => {
          alert('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹æ‰‹å‹•è¤‡è£½ï¼š\n' + url);
        });
      };
    }

    function getDisplayName(side) {
      if (side === 'left') return leftOwnerId || 'ä¸»æ’­ A';
      return rightOwnerId || 'ä¸»æ’­ B';
    }

    function renderVoteUI() {
      if (!leftLabelEl || !rightLabelEl) return;
      const leftName = getDisplayName('left');
      const rightName = getDisplayName('right');
      const leftKey = leftOwnerId ? String(leftOwnerId) : null;
      const rightKey = rightOwnerId ? String(rightOwnerId) : null;
      const leftCount = (leftKey && latestCounts[leftKey]) ? latestCounts[leftKey] : 0;
      const rightCount = (rightKey && latestCounts[rightKey]) ? latestCounts[rightKey] : 0;
      leftLabelEl.textContent = `${leftName} â€¢ ${leftCount}`;
      rightLabelEl.textContent = `${rightName} â€¢ ${rightCount}`;
      if (voteLeftBtn) {
        voteLeftBtn.dataset.defaultText = `æ”¯æŒ ${leftName}`;
        if (!voteLeftBtn.classList.contains('voted')) voteLeftBtn.textContent = voteLeftBtn.dataset.defaultText;
        // ç•¶å·¦å³ä¸»æ’­ ID éƒ½å·²çŸ¥æ™‚æ‰é–‹æ”¾æŠ•ç¥¨
        voteLeftBtn.disabled = !(leftOwnerId && rightOwnerId);
      }
      if (voteRightBtn) {
        voteRightBtn.dataset.defaultText = `æ”¯æŒ ${rightName}`;
        if (!voteRightBtn.classList.contains('voted')) voteRightBtn.textContent = voteRightBtn.dataset.defaultText;
        voteRightBtn.disabled = !(leftOwnerId && rightOwnerId);
      }
    }

    function createVoteBurst(target) {
      if (!target || typeof target.getBoundingClientRect !== 'function') return;
      const rect = target.getBoundingClientRect();
      const burst = document.createElement('div');
      burst.className = 'vote-burst';
      burst.textContent = '+1';
      burst.style.left = `${rect.left + rect.width / 2}px`;
      burst.style.top = `${rect.top}px`;
      document.body.appendChild(burst);
      requestAnimationFrame(() => burst.classList.add('show'));
      setTimeout(() => { burst.classList.remove('show'); }, 480);
      setTimeout(() => { try { burst.remove(); } catch (e) {} }, 640);
    }

    function flashVoteButton(button) {
      if (!button) return;
      const defaultText = button.dataset.defaultText || button.textContent;
      button.classList.add('voted');
      button.disabled = true;
      button.textContent = 'å·²é€å‡º +1';
      createVoteBurst(button);
      setTimeout(() => {
        button.classList.remove('voted');
        button.disabled = false;
        button.textContent = defaultText;
      }, 1500);
    }

    function showToast(message) {
      if (!message) return;
      let toast = document.getElementById('__pk_toast');
      if (!toast) {
        toast = document.createElement('div');
        toast.id = '__pk_toast';
        toast.className = 'pk-toast';
        document.body.appendChild(toast);
      }
      toast.textContent = message;
      toast.classList.add('show');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { toast.classList.remove('show'); }, 1600);
    }

    function handleVote(side) {
      if (!combinedRoom) return;
      const targetOwner = side === 'left' ? leftOwnerId : rightOwnerId;
      const button = side === 'left' ? voteLeftBtn : voteRightBtn;
      if (!targetOwner) {
        // æŒ‰éˆ•å·²ç¦ç”¨ï¼Œä¸å†å½ˆå‡ºæç¤ºä»¥é™ä½å¹²æ“¾ï¼›ä¿ç•™ä¸€è¡Œè¼•å¾®å°å¼•
        showToast('æ­£åœ¨å–å¾— PK è³‡è¨Šâ€¦');
        return;
      }
      socket.emit('pk-vote', { roomId: combinedRoom, ownerId: targetOwner });
      flashVoteButton(button);
    }

    if (voteLeftBtn) voteLeftBtn.addEventListener('click', () => handleVote('left'));
    if (voteRightBtn) voteRightBtn.addEventListener('click', () => handleVote('right'));

    // --- multi-peer handling: accept offers from two broadcasters and attach to videoA/videoB ---
    const peers = {}; // map broadcasterSocketId -> RTCPeerConnection
    const pendingCandidates = {};
    const assigned = { slotA: null, slotB: null }; // record which peer is on which video

    function attachStreamToSlot(stream, peerId) {
      // assign first free slot
      const videoA = document.getElementById('videoA');
      const videoB = document.getElementById('videoB');
      
      // è¨ºæ–·ï¼šæª¢æŸ¥æ¥æ”¶åˆ°çš„æµè»Œé“
      if (stream) {
        const audioTracks = stream.getAudioTracks();
        const videoTracks = stream.getVideoTracks();
        console.log(`[pk-viewer] ğŸ“¦ Attaching stream from peer ${peerId}: audio=${audioTracks.length} video=${videoTracks.length}`);
        audioTracks.forEach((track, i) => {
          console.log(`[pk-viewer] ğŸ¤ AUDIO track ${i}: enabled=${track.enabled} muted=${track.muted} readyState=${track.readyState} label=${track.label}`);
        });
        videoTracks.forEach((track, i) => {
          console.log(`[pk-viewer] ğŸ“¹ VIDEO track ${i}: enabled=${track.enabled} readyState=${track.readyState} label=${track.label}`);
        });
      }
      if (!assigned.slotA) {
        assigned.slotA = peerId;
        videoA.srcObject = stream;
        // é»˜èªä¸éœéŸ³,å˜—è©¦æ’­æ”¾éŸ³é »
        videoA.muted = false;
        videoA.play().then(() => {
          console.log('[pk-viewer] videoA playing with audio');
        }).catch(err => {
          console.log('[pk-viewer] autoplay blocked, falling back to muted', err);
          videoA.muted = true;
          videoA.play().catch(()=>{});
        });
        return 'A';
      }
      if (!assigned.slotB && assigned.slotA !== peerId) {
        assigned.slotB = peerId;
        videoB.srcObject = stream;
        // é»˜èªä¸éœéŸ³,å˜—è©¦æ’­æ”¾éŸ³é »
        videoB.muted = false;
        videoB.play().then(() => {
          console.log('[pk-viewer] videoB playing with audio');
        }).catch(err => {
          console.log('[pk-viewer] autoplay blocked, falling back to muted', err);
          videoB.muted = true;
          videoB.play().catch(()=>{});
        });
        return 'B';
      }
      // if peer already assigned to a slot, update its video
      if (assigned.slotA === peerId) { videoA.srcObject = stream; return 'A'; }
      if (assigned.slotB === peerId) { videoB.srcObject = stream; return 'B'; }
      return null;
    }

    // è™•ç†ä¸»æ’­é‡é€£ï¼šç•¶ä¸»æ’­é‡æ–°åŠ å…¥æ™‚è‡ªå‹•é‡å»ºé€£æ¥
    socket.on('broadcaster', ({ roomId, broadcasterId }) => {
      try {
        console.log('[pk-viewer] ğŸ”„ Broadcaster reconnected:', broadcasterId, 'in room', roomId);
        if (roomId !== combinedRoom) return;
        
        // å¦‚æœé€™å€‹ broadcaster ä¹‹å‰å·²ç¶“é€£æ¥éï¼Œé‡æ–°ç™¼é€ watcher
        if (peers[broadcasterId] || assigned.slotA === broadcasterId || assigned.slotB === broadcasterId) {
          console.log('[pk-viewer] âœ… Re-emitting watcher for reconnected broadcaster');
          socket.emit('watcher');
        }
      } catch (e) { console.error('[pk-viewer] broadcaster event error:', e); }
    });

    socket.on('offer', async (id, description) => {
      try {
        console.log('[pk-viewer] offer from', id);
        // create pc per broadcaster
        if (peers[id]) {
          try { peers[id].close(); } catch (e) {}
          delete peers[id];
        }
        const pc = new RTCPeerConnection({ 
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' },
            {
              urls: ['turn:numb.viagenie.ca:3478', 'turn:numb.viagenie.ca:3478?transport=tcp', 'turn:numb.viagenie.ca:5349', 'turn:numb.viagenie.ca:5349?transport=tcp'],
              username: 'webrtc@live.com',
              credential: 'muazkhan'
            },
            {
              urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443', 'turn:openrelay.metered.ca:443?transport=tcp'],
              username: 'openrelayproject',
              credential: 'openrelayproject'
            }
          ],
          iceCandidatePoolSize: 20,
          iceTransportPolicy: 'all'
        });
        peers[id] = pc;

        pc.ontrack = ev => {
          try {
            const emoji = ev.track.kind === 'audio' ? 'ğŸ¤' : 'ğŸ“¹';
            console.log(`[pk-viewer] ${emoji} RECEIVED from broadcaster ${id}: kind=${ev.track.kind} enabled=${ev.track.enabled} muted=${ev.track.muted} readyState=${ev.track.readyState}`);
            if (ev.streams[0]) {
              const s = ev.streams[0];
              const audioCount = s.getAudioTracks().length;
              const videoCount = s.getVideoTracks().length;
              console.log(`[pk-viewer] ğŸ“¦ Stream ${s.id} has: audio=${audioCount} video=${videoCount}`);
            }
            attachStreamToSlot(ev.streams[0], id);
          } catch (e) { console.warn('attachStream failed', e); }
        };

        pc.onicecandidate = evt => {
          if (evt.candidate) socket.emit('candidate', id, evt.candidate);
        };

        // add any pending remote candidates
        if (pendingCandidates[id] && pendingCandidates[id].length) {
          for (const c of pendingCandidates[id]) try { pc.addIceCandidate(new RTCIceCandidate(c)); } catch (e) {}
          delete pendingCandidates[id];
        }

        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('answer', id, pc.localDescription);
        console.log('[pk-viewer] sent answer to', id);
      } catch (err) {
        console.error('PK viewer offer handling error', err);
      }
    });

    // handle pk votes updates
      socket.on('pk-votes-updated', ({ counts = {}, total = 0 }) => {
        try {
          latestCounts = counts || {};
          const keys = Object.keys(counts || {});
          if (!leftOwnerId && keys.length) leftOwnerId = keys[0];
          if (!rightOwnerId) {
            const fallback = keys.find(k => k !== leftOwnerId);
            if (fallback) rightOwnerId = fallback;
          }
          if (!rightOwnerId && keys.length === 1 && leftOwnerId !== keys[0]) {
            rightOwnerId = keys[0];
          }
          const leftKey = leftOwnerId ? String(leftOwnerId) : (keys[0] || null);
          const rightKey = rightOwnerId ? String(rightOwnerId) : (keys.find(k => k !== leftKey) || keys[0] || null);
          const leftCount = leftKey ? (counts[leftKey] || 0) : 0;
          const rightCount = rightKey ? (counts[rightKey] || 0) : 0;
          const totalVal = total || leftCount + rightCount || 1;
          if (leftHeatEl) leftHeatEl.style.width = Math.round((leftCount / (totalVal || 1)) * 100) + '%';
          if (rightHeatEl) rightHeatEl.style.width = Math.round((rightCount / (totalVal || 1)) * 100) + '%';
          renderVoteUI();
        } catch (e) { console.warn('failed to update pk votes UI', e); }
      });

    // vote buttons handled via handleVote helper (listeners registered earlier)

    // PK viewer reaction buttons (PK-specific emoji channel)
    document.querySelectorAll('.pk-react-btn').forEach(b => {
      const type = b.dataset.type;
      b.addEventListener('click', () => {
        if (!combinedRoom) return;
        socket.emit('pk-emoji', { roomId: combinedRoom, type });
        spawnEmoji(type, { size: 20 + Math.random() * 18 });
      });
    });

    // emoji animation helper (copied/adapted)
    function spawnEmoji(type, opts = {}) {
      const layer = document.getElementById('reactionLayer');
      if (!layer) return;
      const emoji = document.createElement('div');
      emoji.className = 'emoji-particle';
      emoji.textContent = (type === 'heart') ? 'ğŸ’–' : (type === 'laugh') ? 'ğŸ˜„' : (type === 'cry') ? 'ğŸ˜¢' : 'ğŸ‘';
      const vid = document.getElementById('videoA') || document.getElementById('videoB');
      let startX, startY;
      if (opts.x !== undefined) {
        startX = opts.x;
        startY = opts.y !== undefined ? opts.y : (window.innerHeight * 0.6);
      } else if (vid && typeof vid.getBoundingClientRect === 'function') {
        const r = vid.getBoundingClientRect();
        startX = Math.round(r.right - 36 + (Math.random() - 0.5) * 18);
        startY = Math.round(r.bottom - 18 + (Math.random() - 0.5) * 6);
      } else {
        startX = (window.innerWidth * 0.85 + (Math.random() - 0.5) * 120);
        startY = (window.innerHeight * 0.6 + (Math.random() - 0.5) * 80);
      }
      emoji.style.position = 'fixed';
      emoji.style.left = startX + 'px';
      emoji.style.top = startY + 'px';
      emoji.style.fontSize = (opts.size || (18 + Math.random() * 18)) + 'px';
      emoji.style.pointerEvents = 'none';
      emoji.style.opacity = '1';
      emoji.style.transform = 'translateY(0) scale(1)';
      emoji.style.transition = 'transform 1200ms cubic-bezier(.2,.9,.2,1), opacity 1200ms linear';
      layer.appendChild(emoji);
      requestAnimationFrame(() => {
        const dx = (Math.random() - 0.5) * 40;
        const dy = - (220 + Math.random() * 160);
        const rotate = (Math.random() - 0.5) * 40;
        emoji.style.transform = `translate(${dx}px, ${dy}px) rotate(${rotate}deg) scale(1.05)`;
        emoji.style.opacity = '0';
      });
      setTimeout(() => { try { layer.removeChild(emoji); } catch (e) {} }, 1400);
    }

  // show emoji when server broadcasts PK emoji stream
  socket.on('pk-emoji', data => { spawnEmoji(data.type, { size: 18 + Math.random() * 22 }); });

    socket.on('candidate', (id, candidate) => {
      try {
        const pc = peers[id];
        if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(()=>{});
        else { pendingCandidates[id] = pendingCandidates[id] || []; pendingCandidates[id].push(candidate); }
      } catch (e) { console.warn('candidate handling failed', e); }
    });

    socket.on('bye', id => {
      try {
        console.log('[pk-viewer] âš ï¸ Broadcaster disconnected:', id);
        if (peers[id]) { 
          peers[id].close(); 
          delete peers[id]; 
        }
        const wasSlotA = assigned.slotA === id;
        const wasSlotB = assigned.slotB === id;
        if (wasSlotA) { 
          document.getElementById('videoA').srcObject = null; 
          assigned.slotA = null;
          console.log('[pk-viewer] ğŸ”„ Slot A cleared, waiting for reconnection...');
        }
        if (wasSlotB) { 
          document.getElementById('videoB').srcObject = null; 
          assigned.slotB = null;
          console.log('[pk-viewer] ğŸ”„ Slot B cleared, waiting for reconnection...');
        }
        // ä¸åˆªé™¤ pendingCandidatesï¼Œä»¥ä¾¿é‡é€£æ™‚å¯ä»¥ä½¿ç”¨
      } catch (e) { console.error('[pk-viewer] bye handler error:', e); }
    });

    // --- chat features (reused from viewer.html) ---
    let username = 'åŒ¿åç”¨æˆ¶';
    let avatar = '/uploads/default_avatar.png';
    let userId = null;

    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
      const idForColor = data.userId || data.sender || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar" style="width:36px;height:36px;border-radius:6px;object-fit:cover;vertical-align:middle;margin-right:8px;">` +
                      `<div class="text" style="display:inline-block;vertical-align:middle;"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      while (box.children.length > 50) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      while (box.children.length > 50) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // send chat
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId: combinedRoom, user: username, userId, text, avatar });
      input.value = '';
    }

    const sendBtn = document.getElementById('sendBtn');
    document.getElementById('sendBtn').onclick = sendMessage;
    document.getElementById('chatInput').addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

    // enable send button after profile fetch
    sendBtn.disabled = true;
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) { username = data.username; avatar = data.avatar || avatar; userId = data.id || null; }
      })
      .catch(() => {})
      .finally(() => { sendBtn.disabled = false; });

    // show stream info if available
    if (combinedRoom) {
      fetch(`/api/stream-info?room=${combinedRoom}`).then(r => r.json()).then(info => {
        if (info && info.title) document.getElementById('info').textContent = `${info.title} - æˆ¿é–“ï¼š${combinedRoom}`;
      }).catch(()=>{});
    }
  </script>
</body>
</html>
