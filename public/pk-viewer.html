<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>PK - Viewer</title>
  <link rel="stylesheet" href="style-modern.css">
  <style>
    .pk-container { display:flex; gap:12px; align-items:stretch; }
    .pk-side { flex:1; background:#111; color:#fff; border-radius:8px; padding:8px; }
    video { width:100%; height:calc(100vh - 180px); object-fit:cover; background:#000; border-radius:6px; }
    .pk-vote-btn {
      padding:8px 14px;
      border-radius:6px;
      border:none;
      color:#fff;
      font-weight:600;
      cursor:pointer;
      transition:transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s;
    }
    .pk-vote-btn.left { background:linear-gradient(90deg,#ff6b6b,#ff4081); box-shadow:0 8px 18px rgba(255,64,129,0.25); }
    .pk-vote-btn.right { background:linear-gradient(90deg,#42a5f5,#7c4dff); box-shadow:0 8px 18px rgba(124,77,255,0.25); }
    .pk-vote-btn.voted { opacity:0.85; transform:scale(0.97); }
    .pk-vote-btn:disabled { cursor:not-allowed; opacity:0.6; }
    .pk-react-btn {
      width:50px;
      height:50px;
      border-radius:50%;
      border:none;
      font-size:22px;
      cursor:pointer;
      background:linear-gradient(145deg,#FFB380,#FFCC99);
      color:#fff;
      transition:transform 0.15s ease, box-shadow 0.15s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 4px 10px rgba(255,179,128,0.4);
    }
    .pk-react-btn:hover { transform:translateY(-2px) scale(1.05); box-shadow:0 8px 18px rgba(255,179,128,0.55); }
    .vote-burst {
      position:fixed;
      pointer-events:none;
      color:#fff;
      font-weight:700;
      text-shadow:0 0 8px rgba(255,255,255,0.6);
      opacity:0;
      transform:translate(-50%,0) scale(0.8);
      transition:opacity 0.4s ease, transform 0.4s ease;
      z-index:9999;
    }
    .vote-burst.show { opacity:1; transform:translate(-50%,-45px) scale(1.15); }
    .pk-toast {
      position:fixed;
      bottom:24px;
      left:50%;
      transform:translate(-50%,20px);
      background:rgba(0,0,0,0.78);
      color:#fff;
      padding:10px 18px;
      border-radius:999px;
      box-shadow:0 10px 25px rgba(0,0,0,0.35);
      font-weight:600;
      opacity:0;
      transition:opacity 0.2s ease, transform 0.2s ease;
      z-index:99999;
    }
    .pk-toast.show { opacity:1; transform:translate(-50%,0); }
  </style>
</head>
<body>
  <h2 style="color:#333; text-align:center;">PK 觀看畫面</h2>
  <div id="infoBar" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:6px;justify-content:center;">
    <span style="color:#666;">合併房間：<strong id="roomCode" style="color:#333;">---</strong></span>
    <span style="color:#666;">👥 在線人數：<strong id="viewerCount" style="color:#FF6B35;">0</strong></span>
    <button id="shareBtn" style="padding:6px 12px;border-radius:6px;border:1px solid #FF6B35;background:#FFCC99;color:#000;cursor:pointer;font-weight:600;">📤 分享連結</button>
  </div>
  <div id="info" style="text-align:center; color:#666; margin-bottom:10px;">等待導向中…</div>
  <div class="pk-container">
    <div class="pk-side">
      <h3>主播 A</h3>
      <video id="videoA" autoplay playsinline controls muted></video>
    </div>
    <div class="pk-side">
      <h3>主播 B</h3>
      <video id="videoB" autoplay playsinline controls muted></video>
    </div>
  </div>

  <div style="max-width:980px;margin:10px auto;display:flex;gap:12px;align-items:center;">
    <button id="unmuteAll" style="padding:6px 12px;border-radius:6px;border:1px solid #FF6B35;background:#FFCC99;color:#000;cursor:pointer;font-weight:600;">🔊 點此啟用兩邊聲音</button>
    <span style="color:#666;font-size:13px;">如瀏覽器攔截自動播放，先靜音播放，點一次啟用音訊。</span>
  </div>

  <!-- PK vote / heat UI -->
  <div style="display:flex; gap:12px; margin:12px 0; max-width:980px; margin-left:auto; margin-right:auto;">
    <div style="flex:1; text-align:center;">
      <div id="leftLabel" style="color:#333; font-weight:600; margin-bottom:4px;">主播 A</div>
      <div style="height:18px;background:#f5f5f5;border-radius:10px;margin:8px 12px;overflow:hidden;border:1px solid #e0e0e0;">
        <div id="leftHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#ff6b6b,#ff4081);"></div>
      </div>
  <button id="voteLeft" class="pk-vote-btn left">支持 主播 A</button>
    </div>
    <div style="flex:1; text-align:center;">
      <div id="rightLabel" style="color:#333; font-weight:600; margin-bottom:4px;">主播 B</div>
      <div style="height:18px;background:#f5f5f5;border-radius:10px;margin:8px 12px;overflow:hidden;border:1px solid #e0e0e0;">
        <div id="rightHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#42a5f5,#7c4dff);"></div>
      </div>
    <button id="voteRight" class="pk-vote-btn right">支持 主播 B</button>
    </div>
  </div>

  <!-- reaction buttons for PK viewer -->
  <div style="max-width:980px;margin:8px auto 0;display:flex;gap:8px;justify-content:center;">
    <button class="pk-react-btn" data-type="heart">💖</button>
    <button class="pk-react-btn" data-type="laugh">😄</button>
    <button class="pk-react-btn" data-type="cry">😢</button>
    <button class="pk-react-btn" data-type="like">👍</button>
  </div>
  <div id="reactionLayer" style="position:fixed; right:20px; top:80px; left:20px; bottom:0; pointer-events:none; overflow:visible; z-index:9999;"></div>

  <!-- Chat area for PK viewer (same as regular viewer) -->
  <aside class="chat-area" style="width:100%; max-width:980px; margin:12px auto 0; height:380px;">
    <div id="chatContainer">
      <div id="messages" style="flex:1 1 auto; overflow-y:auto; overflow-x:hidden; padding:8px; display:flex; flex-direction:column; gap:8px; box-sizing:border-box; min-height:0;"></div>
      <div class="chat-input-row">
        <input id="chatInput" placeholder="輸入訊息...">
        <button id="sendBtn" disabled>送出</button>
      </div>
    </div>
  </aside>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const params = new URLSearchParams(window.location.search);
    const combinedRoom = params.get('room');
  // 顯示房間號
  try { const rc = document.getElementById('roomCode'); if (rc) rc.textContent = combinedRoom || '---'; } catch (e) {}
    const leftOwnerParam = params.get('left') || params.get('leftOwner') || null;
    const rightOwnerParam = params.get('right') || params.get('rightOwner') || null;
    // 可選：顯示名稱（不影響投票的 ownerId）
    const leftNameParam = params.get('leftName') || params.get('leftDisplay') || null;
    const rightNameParam = params.get('rightName') || params.get('rightDisplay') || null;
    const leftLabelEl = document.getElementById('leftLabel');
    const rightLabelEl = document.getElementById('rightLabel');
    const leftHeatEl = document.getElementById('leftHeat');
    const rightHeatEl = document.getElementById('rightHeat');
    const voteLeftBtn = document.getElementById('voteLeft');
    const voteRightBtn = document.getElementById('voteRight');
    let leftOwnerId = leftOwnerParam;
    let rightOwnerId = rightOwnerParam;
    let latestCounts = {};
    let toastTimer = null;
    let userUnmuted = false; // user toggles to hear both sides

    const logVideoStatus = (label, v) => {
      if (!v) return;
      console.log(`[pk-viewer] ℹ️ ${label} status: readyState=${v.readyState} paused=${v.paused} muted=${v.muted} hasStream=${!!v.srcObject}`);
    };

    const forcePlay = async (videoEl, label) => {
      if (!videoEl) return;
      const tryPlay = async (mutedFirst) => {
        videoEl.muted = mutedFirst;
        try {
          await videoEl.play();
          console.log(`[pk-viewer] ✅ ${label} playing (${mutedFirst ? 'muted' : 'with sound'}) state=${videoEl.readyState} paused=${videoEl.paused}`);
          return true;
        } catch (err) {
          console.warn(`[pk-viewer] ⚠️ ${label} play failed (muted=${mutedFirst}):`, err);
          return false;
        }
      };

      // If user explicitly unmuted, try with sound first
      if (userUnmuted) {
        if (await tryPlay(false)) return true;
        return await tryPlay(true);
      }

      // Default: muted first for autoplay, then with sound if user later clicks unmute
      return await tryPlay(true);
    };

    // Kick playback with retries to bypass mobile autoplay quirks
    const retryPlay = (videoEl, label) => {
      if (!videoEl) return;
      const srcInfo = videoEl.srcObject ? videoEl.srcObject.id : 'no-stream';
      console.log(`[pk-viewer] ▶️ retryPlay ${label} src=${srcInfo}`);
      forcePlay(videoEl, label).then(ok => {
        if (ok) return;
        setTimeout(() => forcePlay(videoEl, `${label}-retry500ms`), 500);
        setTimeout(() => forcePlay(videoEl, `${label}-retry1500ms`), 1500);
        setTimeout(() => {
          logVideoStatus(`${label}-check2s`, videoEl);
          if (videoEl.paused) forcePlay(videoEl, `${label}-retry2000ms`);
        }, 2000);
      });
    };
  // 初始未取得左右主播 ID 前，先禁用投票按鈕避免誤觸
  if (voteLeftBtn) voteLeftBtn.disabled = true;
  if (voteRightBtn) voteRightBtn.disabled = true;

    if (!combinedRoom) {
      document.getElementById('info').textContent = '錯誤：缺少合併房間編號';
    } else {
      document.getElementById('info').textContent = `合併房間：${combinedRoom}`;
      renderVoteUI();
      // join combined room as viewer - server will have emitted 'pk-merged' instructing redirect
      socket.emit('join-room', combinedRoom);
      // ask to receive streams: emit watcher so broadcasters create offers to this viewer
      socket.emit('watcher');
    }

    // 在線人數更新（沿用服務端 viewer-count 事件）
    socket.on('viewer-count', count => {
      try { const vc = document.getElementById('viewerCount'); if (vc) vc.textContent = String(count); } catch (e) {}
    });

    // 啟用音訊
    const unmuteBtn = document.getElementById('unmuteAll');
    if (unmuteBtn) {
      unmuteBtn.onclick = () => {
        userUnmuted = true;
        const vA = document.getElementById('videoA');
        const vB = document.getElementById('videoB');
        [vA, vB].forEach((v, idx) => {
          if (!v) return;
          v.muted = false;
          v.play().then(() => {
            console.log(`[pk-viewer] ✅ video${idx === 0 ? 'A' : 'B'} unmuted and playing`);
          }).catch(err => {
            console.warn(`[pk-viewer] ⚠️ video${idx === 0 ? 'A' : 'B'} play after unmute failed:`, err);
          });
        });
      };
    }

    // 分享連結
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        const url = `${window.location.origin}/pk-viewer.html?room=${encodeURIComponent(combinedRoom || '')}`;
        navigator.clipboard.writeText(url).then(() => {
          alert(`📎 已複製分享連結：\n${url}`);
        }).catch(() => {
          alert('無法複製到剪貼簿，請手動複製：\n' + url);
        });
      };
    }

    // 接收 server 發來的 broadcaster 信息
    socket.on('broadcaster-info', ({ roomId, broadcasters }) => {
      try {
        console.log('[pk-viewer] Received broadcaster info:', broadcasters);
        if (broadcasters && Array.isArray(broadcasters)) {
          broadcasters.forEach(bInfo => {
            peerToInfo[bInfo.socketId] = bInfo;
            console.log('[pk-viewer] Stored broadcaster', bInfo.socketId, ':', bInfo.username);
          });
          renderVoteUI();
        }
      } catch (e) { console.error('[pk-viewer] broadcaster-info error:', e); }
    });

    function renderVoteUI() {
      if (!leftLabelEl || !rightLabelEl) return;
      
      // Get display names based on actual owner IDs or server-provided info
      // Priority: URL param > peerToInfo username > ownerID > default
      let leftName = leftNameParam;
      if (!leftName && assigned.slotA && peerToInfo[assigned.slotA] && peerToInfo[assigned.slotA].username) {
        leftName = peerToInfo[assigned.slotA].username;
      }
      if (!leftName && leftOwnerParam) leftName = leftOwnerParam;
      if (!leftName && leftOwnerId) leftName = `主播 ${String(leftOwnerId).substring(0, 6)}`;
      if (!leftName) leftName = '主播 A';
      
      let rightName = rightNameParam;
      if (!rightName && assigned.slotB && peerToInfo[assigned.slotB] && peerToInfo[assigned.slotB].username) {
        rightName = peerToInfo[assigned.slotB].username;
      }
      if (!rightName && rightOwnerParam) rightName = rightOwnerParam;
      if (!rightName && rightOwnerId) rightName = `主播 ${String(rightOwnerId).substring(0, 6)}`;
      if (!rightName) rightName = '主播 B';
      
      const leftKey = leftOwnerId ? String(leftOwnerId) : null;
      const rightKey = rightOwnerId ? String(rightOwnerId) : null;
      const leftCount = (leftKey && latestCounts[leftKey]) ? latestCounts[leftKey] : 0;
      const rightCount = (rightKey && latestCounts[rightKey]) ? latestCounts[rightKey] : 0;
      
      leftLabelEl.textContent = `${leftName} • ${leftCount}`;
      rightLabelEl.textContent = `${rightName} • ${rightCount}`;
      
      if (voteLeftBtn) {
        voteLeftBtn.dataset.defaultText = `支持 ${leftName}`;
        voteLeftBtn.dataset.ownerId = leftOwnerId || '';
        if (!voteLeftBtn.classList.contains('voted')) {
          voteLeftBtn.textContent = voteLeftBtn.dataset.defaultText;
        }
        // 當左右主播 ID 都已知時才開放投票
        voteLeftBtn.disabled = !(leftOwnerId && rightOwnerId && leftOwnerId !== rightOwnerId);
      }
      if (voteRightBtn) {
        voteRightBtn.dataset.defaultText = `支持 ${rightName}`;
        voteRightBtn.dataset.ownerId = rightOwnerId || '';
        if (!voteRightBtn.classList.contains('voted')) {
          voteRightBtn.textContent = voteRightBtn.dataset.defaultText;
        }
        voteRightBtn.disabled = !(leftOwnerId && rightOwnerId && leftOwnerId !== rightOwnerId);
      }
      
      console.log(`[pk-viewer] 🎯 Vote UI: L="${leftName}"(${leftOwnerId}) vs R="${rightName}"(${rightOwnerId})`);
    }

    function createVoteBurst(target) {
      if (!target || typeof target.getBoundingClientRect !== 'function') return;
      const rect = target.getBoundingClientRect();
      const burst = document.createElement('div');
      burst.className = 'vote-burst';
      burst.textContent = '+1';
      burst.style.left = `${rect.left + rect.width / 2}px`;
      burst.style.top = `${rect.top}px`;
      document.body.appendChild(burst);
      requestAnimationFrame(() => burst.classList.add('show'));
      setTimeout(() => { burst.classList.remove('show'); }, 480);
      setTimeout(() => { try { burst.remove(); } catch (e) {} }, 640);
    }

    function flashVoteButton(button) {
      if (!button) return;
      const defaultText = button.dataset.defaultText || button.textContent;
      button.classList.add('voted');
      button.disabled = true;
      button.textContent = '已送出 +1';
      createVoteBurst(button);
      setTimeout(() => {
        button.classList.remove('voted');
        button.disabled = false;
        button.textContent = defaultText;
      }, 1500);
    }

    function showToast(message) {
      if (!message) return;
      let toast = document.getElementById('__pk_toast');
      if (!toast) {
        toast = document.createElement('div');
        toast.id = '__pk_toast';
        toast.className = 'pk-toast';
        document.body.appendChild(toast);
      }
      toast.textContent = message;
      toast.classList.add('show');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { toast.classList.remove('show'); }, 1600);
    }

    function handleVote(side) {
      if (!combinedRoom) return;
      const targetOwner = side === 'left' ? leftOwnerId : rightOwnerId;
      const button = side === 'left' ? voteLeftBtn : voteRightBtn;
      
      if (!targetOwner || targetOwner === (side === 'left' ? rightOwnerId : leftOwnerId)) {
        showToast('正在取得 PK 資訊…');
        return;
      }
      
      console.log(`[pk-viewer] 🗳️ Voting for ${side}: ownerId=${targetOwner}`);
      socket.emit('pk-vote', { roomId: combinedRoom, ownerId: targetOwner });
      flashVoteButton(button);
    }

    if (voteLeftBtn) voteLeftBtn.addEventListener('click', () => handleVote('left'));
    if (voteRightBtn) voteRightBtn.addEventListener('click', () => handleVote('right'));

    // --- multi-peer handling: accept offers from two broadcasters and attach to videoA/videoB ---
    const peers = {}; // map broadcasterSocketId -> RTCPeerConnection
    const pendingCandidates = {};
    const assigned = { slotA: null, slotB: null }; // record which peer (socket ID) is on which video
    const peerToOwner = {}; // map peer socket ID to owner user ID for voting
    const peerToInfo = {}; // map peer socket ID to full user info { userId, username, socketId }

    function attachStreamToSlot(stream, peerId) {
      if (!stream) return null;
      
      const videoA = document.getElementById('videoA');
      const videoB = document.getElementById('videoB');
      
      // 診斷：檢查接收到的流軌道
      const audioTracks = stream.getAudioTracks();
      const videoTracks = stream.getVideoTracks();
      console.log(`[pk-viewer] 📦 Stream from peer ${peerId}: audio=${audioTracks.length} video=${videoTracks.length}`);
      
      // Check if this peer is already assigned to a slot - if so, just update the stream
      if (assigned.slotA === peerId) {
        if (videoA.srcObject !== stream) {
          videoA.srcObject = stream;
          console.log('[pk-viewer] ✅ Updated videoA with stream from', peerId);
          videoA.muted = false;
          videoA.play().catch(err => {
            console.log('[pk-viewer] videoA autoplay blocked, muting', err);
            videoA.muted = true;
            videoA.play().catch(()=>{});
          });
        }
        return 'A';
      }
      
      if (assigned.slotB === peerId) {
        if (videoB.srcObject !== stream) {
          videoB.srcObject = stream;
          console.log('[pk-viewer] ✅ Updated videoB with stream from', peerId);
          videoB.muted = false;
          videoB.play().catch(err => {
            console.log('[pk-viewer] videoB autoplay blocked, muting', err);
            videoB.muted = true;
            videoB.play().catch(()=>{});
          });
        }
        return 'B';
      }
      
      // Assign to first available slot
      if (!assigned.slotA) {
        assigned.slotA = peerId;
        videoA.srcObject = stream;
        console.log('[pk-viewer] 🎬 Assigned peer', peerId, 'to videoA (slot A)');
        // Link this peer to leftOwner for voting (prefer URL param owner ID)
        const resolvedLeftOwner = leftOwnerParam || leftOwnerId || (peerToInfo[peerId] && peerToInfo[peerId].userId) || peerId;
        leftOwnerId = resolvedLeftOwner;
        peerToOwner[peerId] = resolvedLeftOwner;
        retryPlay(videoA, 'videoA');
        setTimeout(() => logVideoStatus('videoA-post', videoA), 1200);
        renderVoteUI();
        return 'A';
      }
      
      if (!assigned.slotB) {
        assigned.slotB = peerId;
        videoB.srcObject = stream;
        console.log('[pk-viewer] 🎬 Assigned peer', peerId, 'to videoB (slot B)');
        // Link this peer to rightOwner for voting (prefer URL param owner ID)
        const resolvedRightOwner = rightOwnerParam || rightOwnerId || (peerToInfo[peerId] && peerToInfo[peerId].userId) || peerId;
        rightOwnerId = resolvedRightOwner;
        peerToOwner[peerId] = resolvedRightOwner;
        retryPlay(videoB, 'videoB');
        setTimeout(() => logVideoStatus('videoB-post', videoB), 1200);
        renderVoteUI();
        return 'B';
      }
      
      console.warn('[pk-viewer] ⚠️ No available slot for peer', peerId);
      return null;
    }
https://unsuspectful-pulmonary-tandy.ngrok-free.dev/
    // 處理主播重連：當主播重新加入時自動重建連接
    socket.on('broadcaster', ({ roomId, broadcasterId }) => {
      try {
        console.log('[pk-viewer] 🔄 Broadcaster reconnected:', broadcasterId, 'in room', roomId);
        if (roomId !== combinedRoom) return;
        
        // 如果這個 broadcaster 之前已經連接過，重新發送 watcher
        if (peers[broadcasterId] || assigned.slotA === broadcasterId || assigned.slotB === broadcasterId) {
          console.log('[pk-viewer] ✅ Re-emitting watcher for reconnected broadcaster');
          socket.emit('watcher');
        }
      } catch (e) { console.error('[pk-viewer] broadcaster event error:', e); }
    });

    socket.on('offer', async (id, description) => {
      try {
        console.log('[pk-viewer] offer from', id);
        // create pc per broadcaster
        if (peers[id]) {
          try { peers[id].close(); } catch (e) {}
          delete peers[id];
        }
        const pc = new RTCPeerConnection({ 
          iceServers: [
https://unsuspectful-pulmonary-tandy.ngrok-free.dev/
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' },
            { urls: 'stun:stun.stunprotocol.org:3478' },
            { urls: 'stun:stun1.stunprotocol.org:3478' },
            { urls: 'stun:stunserver.org:3478' },
            {
              urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443', 'turn:openrelay.metered.ca:443?transport=tcp'],
              username: 'openrelayproject',
              credential: 'openrelayproject'
            }
          ],
          iceCandidatePoolSize: 20,
          iceTransportPolicy: 'all'
        });
        peers[id] = pc;

        pc.ontrack = ev => {
          try {
            const emoji = ev.track.kind === 'audio' ? '🎤' : '📹';
            console.log(`[pk-viewer] ${emoji} RECEIVED from broadcaster ${id}: kind=${ev.track.kind} enabled=${ev.track.enabled} muted=${ev.track.muted} readyState=${ev.track.readyState}`);
            if (ev.streams[0]) {
              const s = ev.streams[0];
              const audioCount = s.getAudioTracks().length;
              const videoCount = s.getVideoTracks().length;
              console.log(`[pk-viewer] 📦 Stream ${s.id} has: audio=${audioCount} video=${videoCount}`);
            }
            attachStreamToSlot(ev.streams[0], id);
          } catch (e) { console.warn('attachStream failed', e); }
        };

        pc.onicecandidate = evt => {
          if (evt.candidate) socket.emit('candidate', id, evt.candidate);
        };

        // add any pending remote candidates
        if (pendingCandidates[id] && pendingCandidates[id].length) {
          for (const c of pendingCandidates[id]) try { pc.addIceCandidate(new RTCIceCandidate(c)); } catch (e) {}
          delete pendingCandidates[id];
        }

        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('answer', id, pc.localDescription);
        console.log('[pk-viewer] sent answer to', id);
      } catch (err) {
        console.error('PK viewer offer handling error', err);
      }
    });

    // handle pk votes updates
      socket.on('pk-votes-updated', ({ counts = {}, total = 0 }) => {
        try {
          latestCounts = counts || {};
          const keys = Object.keys(counts || {});
          
          // Only auto-assign owner IDs if they haven't been set by video stream assignment
          if (!leftOwnerId && !assigned.slotA && keys.length > 0) {
            leftOwnerId = keys[0];
            console.log('[pk-viewer] 📊 Auto-assigned leftOwnerId from votes:', leftOwnerId);
          }
          if (!rightOwnerId && !assigned.slotB && keys.length > 1) {
            const fallback = keys.find(k => k !== leftOwnerId);
            if (fallback) {
              rightOwnerId = fallback;
              console.log('[pk-viewer] 📊 Auto-assigned rightOwnerId from votes:', rightOwnerId);
            }
          }
          
          const leftKey = leftOwnerId ? String(leftOwnerId) : null;
          const rightKey = rightOwnerId ? String(rightOwnerId) : null;
          const leftCount = leftKey && counts[leftKey] ? counts[leftKey] : 0;
          const rightCount = rightKey && counts[rightKey] ? counts[rightKey] : 0;
          const totalVal = total || Math.max(leftCount + rightCount, 1);
          
          if (leftHeatEl) leftHeatEl.style.width = Math.round((leftCount / totalVal) * 100) + '%';
          if (rightHeatEl) rightHeatEl.style.width = Math.round((rightCount / totalVal) * 100) + '%';
          
          console.log(`[pk-viewer] 📊 Votes updated: L=${leftCount} (${leftKey}) R=${rightCount} (${rightKey})`);
          renderVoteUI();
        } catch (e) { console.warn('failed to update pk votes UI', e); }
      });

    // vote buttons handled via handleVote helper (listeners registered earlier)

    // PK viewer reaction buttons (PK-specific emoji channel)
    document.querySelectorAll('.pk-react-btn').forEach(b => {
      const type = b.dataset.type;
      b.addEventListener('click', () => {
        if (!combinedRoom) return;
        socket.emit('pk-emoji', { roomId: combinedRoom, type });
        spawnEmoji(type, { size: 20 + Math.random() * 18 });
      });
    });

    // emoji animation helper (copied/adapted)
    function spawnEmoji(type, opts = {}) {
      const layer = document.getElementById('reactionLayer');
      if (!layer) return;
      const emoji = document.createElement('div');
      emoji.className = 'emoji-particle';
      emoji.textContent = (type === 'heart') ? '💖' : (type === 'laugh') ? '😄' : (type === 'cry') ? '😢' : '👍';
      const vid = document.getElementById('videoA') || document.getElementById('videoB');
      let startX, startY;
      if (opts.x !== undefined) {
        startX = opts.x;
        startY = opts.y !== undefined ? opts.y : (window.innerHeight * 0.6);
      } else if (vid && typeof vid.getBoundingClientRect === 'function') {
        const r = vid.getBoundingClientRect();
        startX = Math.round(r.right - 36 + (Math.random() - 0.5) * 18);
        startY = Math.round(r.bottom - 18 + (Math.random() - 0.5) * 6);
      } else {
        startX = (window.innerWidth * 0.85 + (Math.random() - 0.5) * 120);
        startY = (window.innerHeight * 0.6 + (Math.random() - 0.5) * 80);
      }
      emoji.style.position = 'fixed';
      emoji.style.left = startX + 'px';
      emoji.style.top = startY + 'px';
      emoji.style.fontSize = (opts.size || (18 + Math.random() * 18)) + 'px';
      emoji.style.pointerEvents = 'none';
      emoji.style.opacity = '1';
      emoji.style.transform = 'translateY(0) scale(1)';
      emoji.style.transition = 'transform 1200ms cubic-bezier(.2,.9,.2,1), opacity 1200ms linear';
      layer.appendChild(emoji);
      requestAnimationFrame(() => {
        const dx = (Math.random() - 0.5) * 40;
        const dy = - (220 + Math.random() * 160);
        const rotate = (Math.random() - 0.5) * 40;
        emoji.style.transform = `translate(${dx}px, ${dy}px) rotate(${rotate}deg) scale(1.05)`;
        emoji.style.opacity = '0';
      });
      setTimeout(() => { try { layer.removeChild(emoji); } catch (e) {} }, 1400);
    }

  // show emoji when server broadcasts PK emoji stream
  socket.on('pk-emoji', data => { spawnEmoji(data.type, { size: 18 + Math.random() * 22 }); });

    socket.on('candidate', (id, candidate) => {
      try {
        const pc = peers[id];
        if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(()=>{});
        else { pendingCandidates[id] = pendingCandidates[id] || []; pendingCandidates[id].push(candidate); }
      } catch (e) { console.warn('candidate handling failed', e); }
    });

    socket.on('bye', id => {
      try {
        console.log('[pk-viewer] ⚠️ Broadcaster disconnected:', id);
        if (peers[id]) { 
          peers[id].close(); 
          delete peers[id]; 
        }
        const wasSlotA = assigned.slotA === id;
        const wasSlotB = assigned.slotB === id;
        if (wasSlotA) { 
          document.getElementById('videoA').srcObject = null; 
          assigned.slotA = null;
          console.log('[pk-viewer] 🔄 Slot A cleared, waiting for reconnection...');
        }
        if (wasSlotB) { 
          document.getElementById('videoB').srcObject = null; 
          assigned.slotB = null;
          console.log('[pk-viewer] 🔄 Slot B cleared, waiting for reconnection...');
        }
        // 不刪除 pendingCandidates，以便重連時可以使用
      } catch (e) { console.error('[pk-viewer] bye handler error:', e); }
    });

    // --- chat features (reused from viewer.html) ---
    let username = '匿名用戶';
    let avatar = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Crect fill="%23e0e0e0" width="200" height="200"/%3E%3Ccircle cx="100" cy="70" r="40" fill="%23999"/%3E%3Cellipse cx="100" cy="150" rx="50" ry="40" fill="%23999"/%3E%3C/svg%3E';
    let userId = null;

    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `👑 ${data.user}` : data.user;
      const idForColor = data.userId || data.sender || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar" style="width:36px;height:36px;border-radius:6px;object-fit:cover;vertical-align:middle;margin-right:8px;">` +
                      `<div class="text" style="display:inline-block;vertical-align:middle;"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      while (box.children.length > 50) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      while (box.children.length > 50) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // send chat
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId: combinedRoom, user: username, userId, text, avatar });
      input.value = '';
    }

    const sendBtn = document.getElementById('sendBtn');
    document.getElementById('sendBtn').onclick = sendMessage;
    document.getElementById('chatInput').addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

    // enable send button after profile fetch
    sendBtn.disabled = true;
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) { username = data.username; avatar = data.avatar || avatar; userId = data.id || null; }
      })
      .catch(() => {})
      .finally(() => { sendBtn.disabled = false; });

    // show stream info if available
    if (combinedRoom) {
      fetch(`/api/stream-info?room=${combinedRoom}`).then(r => r.json()).then(info => {
        if (info && info.title) document.getElementById('info').textContent = `${info.title} - 房間：${combinedRoom}`;
      }).catch(()=>{});
    }
  </script>
</body>
</html>

