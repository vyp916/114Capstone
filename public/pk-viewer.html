<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>PK - Viewer</title>
  <link rel="stylesheet" href="style-modern.css">
  <style>
    .pk-container { display:flex; gap:12px; align-items:stretch; }
    .pk-side { flex:1; background:#111; color:#fff; border-radius:8px; padding:8px; }
    video { width:100%; height:calc(100vh - 180px); object-fit:cover; background:#000; border-radius:6px; }
    .pk-vote-btn {
      padding:8px 14px;
      border-radius:6px;
      border:none;
      color:#fff;
      font-weight:600;
      cursor:pointer;
      transition:transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s;
    }
    .pk-vote-btn.left { background:linear-gradient(90deg,#ff6b6b,#ff4081); box-shadow:0 8px 18px rgba(255,64,129,0.25); }
    .pk-vote-btn.right { background:linear-gradient(90deg,#42a5f5,#7c4dff); box-shadow:0 8px 18px rgba(124,77,255,0.25); }
    .pk-vote-btn.voted { opacity:0.85; transform:scale(0.97); }
    .pk-vote-btn:disabled { cursor:not-allowed; opacity:0.6; }
    .pk-react-btn {
      width:50px;
      height:50px;
      border-radius:50%;
      border:none;
      font-size:22px;
      cursor:pointer;
      background:linear-gradient(145deg,#FFB380,#FFCC99);
      color:#fff;
      transition:transform 0.15s ease, box-shadow 0.15s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 4px 10px rgba(255,179,128,0.4);
    }
    .pk-react-btn:hover { transform:translateY(-2px) scale(1.05); box-shadow:0 8px 18px rgba(255,179,128,0.55); }
    .vote-burst {
      position:fixed;
      pointer-events:none;
      color:#fff;
      font-weight:700;
      text-shadow:0 0 8px rgba(255,255,255,0.6);
      opacity:0;
      transform:translate(-50%,0) scale(0.8);
      transition:opacity 0.4s ease, transform 0.4s ease;
      z-index:9999;
    }
    .vote-burst.show { opacity:1; transform:translate(-50%,-45px) scale(1.15); }
    .pk-toast {
      position:fixed;
      bottom:24px;
      left:50%;
      transform:translate(-50%,20px);
      background:rgba(0,0,0,0.78);
      color:#fff;
      padding:10px 18px;
      border-radius:999px;
      box-shadow:0 10px 25px rgba(0,0,0,0.35);
      font-weight:600;
      opacity:0;
      transition:opacity 0.2s ease, transform 0.2s ease;
      z-index:99999;
    }
    .pk-toast.show { opacity:1; transform:translate(-50%,0); }
  </style>
</head>
<body>
  <h2 style="color:#333; text-align:center;">PK è§€çœ‹ç•«é¢</h2>
  <div id="infoBar" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:6px;justify-content:center;">
    <span style="color:#666;">åˆä½µæˆ¿é–“ï¼š<strong id="roomCode" style="color:#333;">---</strong></span>
    <span style="color:#666;">ğŸ‘¥ åœ¨ç·šäººæ•¸ï¼š<strong id="viewerCount" style="color:#FF6B35;">0</strong></span>
    <button id="shareBtn" style="padding:6px 12px;border-radius:6px;border:1px solid #FF6B35;background:#FFCC99;color:#000;cursor:pointer;font-weight:600;">ğŸ“¤ åˆ†äº«é€£çµ</button>
  </div>
  <div id="info" style="text-align:center; color:#666; margin-bottom:10px;">ç­‰å¾…å°å‘ä¸­â€¦</div>
  <div class="pk-container">
    <div class="pk-side">
      <h3>ä¸»æ’­ A</h3>
      <video id="videoA" autoplay playsinline controls></video>
    </div>
    <div class="pk-side">
      <h3>ä¸»æ’­ B</h3>
      <video id="videoB" autoplay playsinline controls></video>
    </div>
  </div>

  <!-- PK vote / heat UI -->
  <div style="display:flex; gap:12px; margin:12px 0; max-width:980px; margin-left:auto; margin-right:auto;">
    <div style="flex:1; text-align:center;">
      <div id="leftLabel" style="color:#333; font-weight:600; margin-bottom:4px;">ä¸»æ’­ A</div>
      <div style="height:18px;background:#f5f5f5;border-radius:10px;margin:8px 12px;overflow:hidden;border:1px solid #e0e0e0;">
        <div id="leftHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#ff6b6b,#ff4081);"></div>
      </div>
  <button id="voteLeft" class="pk-vote-btn left">æ”¯æŒ ä¸»æ’­ A</button>
    </div>
    <div style="flex:1; text-align:center;">
      <div id="rightLabel" style="color:#333; font-weight:600; margin-bottom:4px;">ä¸»æ’­ B</div>
      <div style="height:18px;background:#f5f5f5;border-radius:10px;margin:8px 12px;overflow:hidden;border:1px solid #e0e0e0;">
        <div id="rightHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#42a5f5,#7c4dff);"></div>
      </div>
    <button id="voteRight" class="pk-vote-btn right">æ”¯æŒ ä¸»æ’­ B</button>
    </div>
  </div>

  <!-- reaction buttons for PK viewer -->
  <div style="max-width:980px;margin:8px auto 0;display:flex;gap:8px;justify-content:center;">
    <button class="pk-react-btn" data-type="heart">ğŸ’–</button>
    <button class="pk-react-btn" data-type="laugh">ğŸ˜„</button>
    <button class="pk-react-btn" data-type="cry">ğŸ˜¢</button>
    <button class="pk-react-btn" data-type="like">ğŸ‘</button>
  </div>
  <div id="reactionLayer" style="position:fixed; right:20px; top:80px; left:20px; bottom:0; pointer-events:none; overflow:visible; z-index:9999;"></div>

  <!-- Chat area for PK viewer (same as regular viewer) -->
  <aside class="chat-area" style="width:100%; max-width:980px; margin:12px auto 0; height:380px;">
    <div id="chatContainer">
      <div id="messages" style="flex:1 1 auto; overflow-y:auto; overflow-x:hidden; padding:8px; display:flex; flex-direction:column; gap:8px; box-sizing:border-box; min-height:0;"></div>
      <div class="chat-input-row">
        <input id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯...">
        <button id="sendBtn" disabled>é€å‡º</button>
      </div>
    </div>
  </aside>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const params = new URLSearchParams(window.location.search);
    const combinedRoom = params.get('room');
  // é¡¯ç¤ºæˆ¿é–“è™Ÿ
  try { const rc = document.getElementById('roomCode'); if (rc) rc.textContent = combinedRoom || '---'; } catch (e) {}
    const leftOwnerParam = params.get('left') || params.get('leftOwner') || null;
    const rightOwnerParam = params.get('right') || params.get('rightOwner') || null;
    const leftLabelEl = document.getElementById('leftLabel');
    const rightLabelEl = document.getElementById('rightLabel');
    const leftHeatEl = document.getElementById('leftHeat');
    const rightHeatEl = document.getElementById('rightHeat');
    const voteLeftBtn = document.getElementById('voteLeft');
    const voteRightBtn = document.getElementById('voteRight');
    let leftOwnerId = leftOwnerParam;
    let rightOwnerId = rightOwnerParam;
    let latestCounts = {};
    let toastTimer = null;
  // åˆå§‹æœªå–å¾—å·¦å³ä¸»æ’­ ID å‰ï¼Œå…ˆç¦ç”¨æŠ•ç¥¨æŒ‰éˆ•é¿å…èª¤è§¸
  if (voteLeftBtn) voteLeftBtn.disabled = true;
  if (voteRightBtn) voteRightBtn.disabled = true;

    if (!combinedRoom) {
      document.getElementById('info').textContent = 'éŒ¯èª¤ï¼šç¼ºå°‘åˆä½µæˆ¿é–“ç·¨è™Ÿ';
    } else {
      document.getElementById('info').textContent = `åˆä½µæˆ¿é–“ï¼š${combinedRoom}`;
      renderVoteUI();
      // join combined room as viewer - server will have emitted 'pk-merged' instructing redirect
      socket.emit('join-room', combinedRoom);
      // ask to receive streams: emit watcher so broadcasters create offers to this viewer
      socket.emit('watcher');
    }

    // åœ¨ç·šäººæ•¸æ›´æ–°ï¼ˆæ²¿ç”¨æœå‹™ç«¯ viewer-count äº‹ä»¶ï¼‰
    socket.on('viewer-count', count => {
      try { const vc = document.getElementById('viewerCount'); if (vc) vc.textContent = String(count); } catch (e) {}
    });

    // åˆ†äº«é€£çµ
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        const url = `${window.location.origin}/pk-viewer.html?room=${encodeURIComponent(combinedRoom || '')}`;
        navigator.clipboard.writeText(url).then(() => {
          alert(`ğŸ“ å·²è¤‡è£½åˆ†äº«é€£çµï¼š\n${url}`);
        }).catch(() => {
          alert('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹æ‰‹å‹•è¤‡è£½ï¼š\n' + url);
        });
      };
    }

    function renderVoteUI() {
      if (!leftLabelEl || !rightLabelEl) return;
      
      // Get display names based on actual owner IDs
      const leftName = leftOwnerParam || (leftOwnerId ? `ä¸»æ’­ ${String(leftOwnerId).substring(0, 6)}` : 'ä¸»æ’­ A');
      const rightName = rightOwnerParam || (rightOwnerId ? `ä¸»æ’­ ${String(rightOwnerId).substring(0, 6)}` : 'ä¸»æ’­ B');
      
      const leftKey = leftOwnerId ? String(leftOwnerId) : null;
      const rightKey = rightOwnerId ? String(rightOwnerId) : null;
      const leftCount = (leftKey && latestCounts[leftKey]) ? latestCounts[leftKey] : 0;
      const rightCount = (rightKey && latestCounts[rightKey]) ? latestCounts[rightKey] : 0;
      
      leftLabelEl.textContent = `${leftName} â€¢ ${leftCount}`;
      rightLabelEl.textContent = `${rightName} â€¢ ${rightCount}`;
      
      if (voteLeftBtn) {
        voteLeftBtn.dataset.defaultText = `æ”¯æŒ ${leftName}`;
        voteLeftBtn.dataset.ownerId = leftOwnerId || '';
        if (!voteLeftBtn.classList.contains('voted')) {
          voteLeftBtn.textContent = voteLeftBtn.dataset.defaultText;
        }
        // ç•¶å·¦å³ä¸»æ’­ ID éƒ½å·²çŸ¥æ™‚æ‰é–‹æ”¾æŠ•ç¥¨
        voteLeftBtn.disabled = !(leftOwnerId && rightOwnerId && leftOwnerId !== rightOwnerId);
      }
      if (voteRightBtn) {
        voteRightBtn.dataset.defaultText = `æ”¯æŒ ${rightName}`;
        voteRightBtn.dataset.ownerId = rightOwnerId || '';
        if (!voteRightBtn.classList.contains('voted')) {
          voteRightBtn.textContent = voteRightBtn.dataset.defaultText;
        }
        voteRightBtn.disabled = !(leftOwnerId && rightOwnerId && leftOwnerId !== rightOwnerId);
      }
      
      console.log(`[pk-viewer] ğŸ¯ Vote UI: L="${leftName}"(${leftOwnerId}) vs R="${rightName}"(${rightOwnerId})`);
    }

    function createVoteBurst(target) {
      if (!target || typeof target.getBoundingClientRect !== 'function') return;
      const rect = target.getBoundingClientRect();
      const burst = document.createElement('div');
      burst.className = 'vote-burst';
      burst.textContent = '+1';
      burst.style.left = `${rect.left + rect.width / 2}px`;
      burst.style.top = `${rect.top}px`;
      document.body.appendChild(burst);
      requestAnimationFrame(() => burst.classList.add('show'));
      setTimeout(() => { burst.classList.remove('show'); }, 480);
      setTimeout(() => { try { burst.remove(); } catch (e) {} }, 640);
    }

    function flashVoteButton(button) {
      if (!button) return;
      const defaultText = button.dataset.defaultText || button.textContent;
      button.classList.add('voted');
      button.disabled = true;
      button.textContent = 'å·²é€å‡º +1';
      createVoteBurst(button);
      setTimeout(() => {
        button.classList.remove('voted');
        button.disabled = false;
        button.textContent = defaultText;
      }, 1500);
    }

    function showToast(message) {
      if (!message) return;
      let toast = document.getElementById('__pk_toast');
      if (!toast) {
        toast = document.createElement('div');
        toast.id = '__pk_toast';
        toast.className = 'pk-toast';
        document.body.appendChild(toast);
      }
      toast.textContent = message;
      toast.classList.add('show');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { toast.classList.remove('show'); }, 1600);
    }

    function handleVote(side) {
      if (!combinedRoom) return;
      const targetOwner = side === 'left' ? leftOwnerId : rightOwnerId;
      const button = side === 'left' ? voteLeftBtn : voteRightBtn;
      
      if (!targetOwner || targetOwner === (side === 'left' ? rightOwnerId : leftOwnerId)) {
        showToast('æ­£åœ¨å–å¾— PK è³‡è¨Šâ€¦');
        return;
      }
      
      console.log(`[pk-viewer] ğŸ—³ï¸ Voting for ${side}: ownerId=${targetOwner}`);
      socket.emit('pk-vote', { roomId: combinedRoom, ownerId: targetOwner });
      flashVoteButton(button);
    }

    if (voteLeftBtn) voteLeftBtn.addEventListener('click', () => handleVote('left'));
    if (voteRightBtn) voteRightBtn.addEventListener('click', () => handleVote('right'));

    // --- multi-peer handling: accept offers from two broadcasters and attach to videoA/videoB ---
    const peers = {}; // map broadcasterSocketId -> RTCPeerConnection
    const pendingCandidates = {};
    const assigned = { slotA: null, slotB: null }; // record which peer (socket ID) is on which video
    const peerToOwner = {}; // map peer socket ID to owner user ID for voting

    function attachStreamToSlot(stream, peerId) {
      if (!stream) return null;
      
      const videoA = document.getElementById('videoA');
      const videoB = document.getElementById('videoB');
      
      // è¨ºæ–·ï¼šæª¢æŸ¥æ¥æ”¶åˆ°çš„æµè»Œé“
      const audioTracks = stream.getAudioTracks();
      const videoTracks = stream.getVideoTracks();
      console.log(`[pk-viewer] ğŸ“¦ Stream from peer ${peerId}: audio=${audioTracks.length} video=${videoTracks.length}`);
      
      // Check if this peer is already assigned to a slot - if so, just update the stream
      if (assigned.slotA === peerId) {
        if (videoA.srcObject !== stream) {
          videoA.srcObject = stream;
          console.log('[pk-viewer] âœ… Updated videoA with stream from', peerId);
          videoA.muted = false;
          videoA.play().catch(err => {
            console.log('[pk-viewer] videoA autoplay blocked, muting', err);
            videoA.muted = true;
            videoA.play().catch(()=>{});
          });
        }
        return 'A';
      }
      
      if (assigned.slotB === peerId) {
        if (videoB.srcObject !== stream) {
          videoB.srcObject = stream;
          console.log('[pk-viewer] âœ… Updated videoB with stream from', peerId);
          videoB.muted = false;
          videoB.play().catch(err => {
            console.log('[pk-viewer] videoB autoplay blocked, muting', err);
            videoB.muted = true;
            videoB.play().catch(()=>{});
          });
        }
        return 'B';
      }
      
      // Assign to first available slot
      if (!assigned.slotA) {
        assigned.slotA = peerId;
        videoA.srcObject = stream;
        console.log('[pk-viewer] ğŸ¬ Assigned peer', peerId, 'to videoA (slot A)');
        // Link this peer to leftOwner for voting
        if (!leftOwnerId) leftOwnerId = peerId;
        peerToOwner[peerId] = leftOwnerId;
        videoA.muted = false;
        videoA.play().catch(err => {
          console.log('[pk-viewer] videoA autoplay blocked, muting', err);
          videoA.muted = true;
          videoA.play().catch(()=>{});
        });
        renderVoteUI();
        return 'A';
      }
      
      if (!assigned.slotB) {
        assigned.slotB = peerId;
        videoB.srcObject = stream;
        console.log('[pk-viewer] ğŸ¬ Assigned peer', peerId, 'to videoB (slot B)');
        // Link this peer to rightOwner for voting
        if (!rightOwnerId) rightOwnerId = peerId;
        peerToOwner[peerId] = rightOwnerId;
        videoB.muted = false;
        videoB.play().catch(err => {
          console.log('[pk-viewer] videoB autoplay blocked, muting', err);
          videoB.muted = true;
          videoB.play().catch(()=>{});
        });
        renderVoteUI();
        return 'B';
      }
      
      console.warn('[pk-viewer] âš ï¸ No available slot for peer', peerId);
      return null;
    }

    // è™•ç†ä¸»æ’­é‡é€£ï¼šç•¶ä¸»æ’­é‡æ–°åŠ å…¥æ™‚è‡ªå‹•é‡å»ºé€£æ¥
    socket.on('broadcaster', ({ roomId, broadcasterId }) => {
      try {
        console.log('[pk-viewer] ğŸ”„ Broadcaster reconnected:', broadcasterId, 'in room', roomId);
        if (roomId !== combinedRoom) return;
        
        // å¦‚æœé€™å€‹ broadcaster ä¹‹å‰å·²ç¶“é€£æ¥éï¼Œé‡æ–°ç™¼é€ watcher
        if (peers[broadcasterId] || assigned.slotA === broadcasterId || assigned.slotB === broadcasterId) {
          console.log('[pk-viewer] âœ… Re-emitting watcher for reconnected broadcaster');
          socket.emit('watcher');
        }
      } catch (e) { console.error('[pk-viewer] broadcaster event error:', e); }
    });

    socket.on('offer', async (id, description) => {
      try {
        console.log('[pk-viewer] offer from', id);
        // create pc per broadcaster
        if (peers[id]) {
          try { peers[id].close(); } catch (e) {}
          delete peers[id];
        }
        const pc = new RTCPeerConnection({ 
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' },
            { urls: 'stun:stun.stunprotocol.org:3478' },
            { urls: 'stun:stun1.stunprotocol.org:3478' },
            { urls: 'stun:stunserver.org:3478' },
            {
              urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443', 'turn:openrelay.metered.ca:443?transport=tcp'],
              username: 'openrelayproject',
              credential: 'openrelayproject'
            }
          ],
          iceCandidatePoolSize: 20,
          iceTransportPolicy: 'all'
        });
        peers[id] = pc;

        pc.ontrack = ev => {
          try {
            const emoji = ev.track.kind === 'audio' ? 'ğŸ¤' : 'ğŸ“¹';
            console.log(`[pk-viewer] ${emoji} RECEIVED from broadcaster ${id}: kind=${ev.track.kind} enabled=${ev.track.enabled} muted=${ev.track.muted} readyState=${ev.track.readyState}`);
            if (ev.streams[0]) {
              const s = ev.streams[0];
              const audioCount = s.getAudioTracks().length;
              const videoCount = s.getVideoTracks().length;
              console.log(`[pk-viewer] ğŸ“¦ Stream ${s.id} has: audio=${audioCount} video=${videoCount}`);
            }
            attachStreamToSlot(ev.streams[0], id);
          } catch (e) { console.warn('attachStream failed', e); }
        };

        pc.onicecandidate = evt => {
          if (evt.candidate) socket.emit('candidate', id, evt.candidate);
        };

        // add any pending remote candidates
        if (pendingCandidates[id] && pendingCandidates[id].length) {
          for (const c of pendingCandidates[id]) try { pc.addIceCandidate(new RTCIceCandidate(c)); } catch (e) {}
          delete pendingCandidates[id];
        }

        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('answer', id, pc.localDescription);
        console.log('[pk-viewer] sent answer to', id);
      } catch (err) {
        console.error('PK viewer offer handling error', err);
      }
    });

    // handle pk votes updates
      socket.on('pk-votes-updated', ({ counts = {}, total = 0 }) => {
        try {
          latestCounts = counts || {};
          const keys = Object.keys(counts || {});
          
          // Only auto-assign owner IDs if they haven't been set by video stream assignment
          if (!leftOwnerId && !assigned.slotA && keys.length > 0) {
            leftOwnerId = keys[0];
            console.log('[pk-viewer] ğŸ“Š Auto-assigned leftOwnerId from votes:', leftOwnerId);
          }
          if (!rightOwnerId && !assigned.slotB && keys.length > 1) {
            const fallback = keys.find(k => k !== leftOwnerId);
            if (fallback) {
              rightOwnerId = fallback;
              console.log('[pk-viewer] ğŸ“Š Auto-assigned rightOwnerId from votes:', rightOwnerId);
            }
          }
          
          const leftKey = leftOwnerId ? String(leftOwnerId) : null;
          const rightKey = rightOwnerId ? String(rightOwnerId) : null;
          const leftCount = leftKey && counts[leftKey] ? counts[leftKey] : 0;
          const rightCount = rightKey && counts[rightKey] ? counts[rightKey] : 0;
          const totalVal = total || Math.max(leftCount + rightCount, 1);
          
          if (leftHeatEl) leftHeatEl.style.width = Math.round((leftCount / totalVal) * 100) + '%';
          if (rightHeatEl) rightHeatEl.style.width = Math.round((rightCount / totalVal) * 100) + '%';
          
          console.log(`[pk-viewer] ğŸ“Š Votes updated: L=${leftCount} (${leftKey}) R=${rightCount} (${rightKey})`);
          renderVoteUI();
        } catch (e) { console.warn('failed to update pk votes UI', e); }
      });

    // vote buttons handled via handleVote helper (listeners registered earlier)

    // PK viewer reaction buttons (PK-specific emoji channel)
    document.querySelectorAll('.pk-react-btn').forEach(b => {
      const type = b.dataset.type;
      b.addEventListener('click', () => {
        if (!combinedRoom) return;
        socket.emit('pk-emoji', { roomId: combinedRoom, type });
        spawnEmoji(type, { size: 20 + Math.random() * 18 });
      });
    });

    // emoji animation helper (copied/adapted)
    function spawnEmoji(type, opts = {}) {
      const layer = document.getElementById('reactionLayer');
      if (!layer) return;
      const emoji = document.createElement('div');
      emoji.className = 'emoji-particle';
      emoji.textContent = (type === 'heart') ? 'ğŸ’–' : (type === 'laugh') ? 'ğŸ˜„' : (type === 'cry') ? 'ğŸ˜¢' : 'ğŸ‘';
      const vid = document.getElementById('videoA') || document.getElementById('videoB');
      let startX, startY;
      if (opts.x !== undefined) {
        startX = opts.x;
        startY = opts.y !== undefined ? opts.y : (window.innerHeight * 0.6);
      } else if (vid && typeof vid.getBoundingClientRect === 'function') {
        const r = vid.getBoundingClientRect();
        startX = Math.round(r.right - 36 + (Math.random() - 0.5) * 18);
        startY = Math.round(r.bottom - 18 + (Math.random() - 0.5) * 6);
      } else {
        startX = (window.innerWidth * 0.85 + (Math.random() - 0.5) * 120);
        startY = (window.innerHeight * 0.6 + (Math.random() - 0.5) * 80);
      }
      emoji.style.position = 'fixed';
      emoji.style.left = startX + 'px';
      emoji.style.top = startY + 'px';
      emoji.style.fontSize = (opts.size || (18 + Math.random() * 18)) + 'px';
      emoji.style.pointerEvents = 'none';
      emoji.style.opacity = '1';
      emoji.style.transform = 'translateY(0) scale(1)';
      emoji.style.transition = 'transform 1200ms cubic-bezier(.2,.9,.2,1), opacity 1200ms linear';
      layer.appendChild(emoji);
      requestAnimationFrame(() => {
        const dx = (Math.random() - 0.5) * 40;
        const dy = - (220 + Math.random() * 160);
        const rotate = (Math.random() - 0.5) * 40;
        emoji.style.transform = `translate(${dx}px, ${dy}px) rotate(${rotate}deg) scale(1.05)`;
        emoji.style.opacity = '0';
      });
      setTimeout(() => { try { layer.removeChild(emoji); } catch (e) {} }, 1400);
    }

  // show emoji when server broadcasts PK emoji stream
  socket.on('pk-emoji', data => { spawnEmoji(data.type, { size: 18 + Math.random() * 22 }); });

    socket.on('candidate', (id, candidate) => {
      try {
        const pc = peers[id];
        if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(()=>{});
        else { pendingCandidates[id] = pendingCandidates[id] || []; pendingCandidates[id].push(candidate); }
      } catch (e) { console.warn('candidate handling failed', e); }
    });

    socket.on('bye', id => {
      try {
        console.log('[pk-viewer] âš ï¸ Broadcaster disconnected:', id);
        if (peers[id]) { 
          peers[id].close(); 
          delete peers[id]; 
        }
        const wasSlotA = assigned.slotA === id;
        const wasSlotB = assigned.slotB === id;
        if (wasSlotA) { 
          document.getElementById('videoA').srcObject = null; 
          assigned.slotA = null;
          console.log('[pk-viewer] ğŸ”„ Slot A cleared, waiting for reconnection...');
        }
        if (wasSlotB) { 
          document.getElementById('videoB').srcObject = null; 
          assigned.slotB = null;
          console.log('[pk-viewer] ğŸ”„ Slot B cleared, waiting for reconnection...');
        }
        // ä¸åˆªé™¤ pendingCandidatesï¼Œä»¥ä¾¿é‡é€£æ™‚å¯ä»¥ä½¿ç”¨
      } catch (e) { console.error('[pk-viewer] bye handler error:', e); }
    });

    // --- chat features (reused from viewer.html) ---
    let username = 'åŒ¿åç”¨æˆ¶';
    let avatar = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Crect fill="%23e0e0e0" width="200" height="200"/%3E%3Ccircle cx="100" cy="70" r="40" fill="%23999"/%3E%3Cellipse cx="100" cy="150" rx="50" ry="40" fill="%23999"/%3E%3C/svg%3E';
    let userId = null;

    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
      const idForColor = data.userId || data.sender || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar" style="width:36px;height:36px;border-radius:6px;object-fit:cover;vertical-align:middle;margin-right:8px;">` +
                      `<div class="text" style="display:inline-block;vertical-align:middle;"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      while (box.children.length > 50) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      while (box.children.length > 50) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // send chat
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId: combinedRoom, user: username, userId, text, avatar });
      input.value = '';
    }

    const sendBtn = document.getElementById('sendBtn');
    document.getElementById('sendBtn').onclick = sendMessage;
    document.getElementById('chatInput').addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });

    // enable send button after profile fetch
    sendBtn.disabled = true;
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) { username = data.username; avatar = data.avatar || avatar; userId = data.id || null; }
      })
      .catch(() => {})
      .finally(() => { sendBtn.disabled = false; });

    // show stream info if available
    if (combinedRoom) {
      fetch(`/api/stream-info?room=${combinedRoom}`).then(r => r.json()).then(info => {
        if (info && info.title) document.getElementById('info').textContent = `${info.title} - æˆ¿é–“ï¼š${combinedRoom}`;
      }).catch(()=>{});
    }
  </script>
</body>
</html>
