<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>PK - Broadcaster</title>
  <link rel="stylesheet" href="style-modern.css">
  <style>
    .pk-container { display:flex; gap:12px; align-items:stretch; }
    .pk-side { flex:1; background:#111; color:#fff; border-radius:8px; padding:8px; }
    video { width:100%; height:calc(100vh - 180px); object-fit:cover; background:#000; border-radius:6px; }
    .pk-react-btn {
      width:50px;
      height:50px;
      border-radius:50%;
      border:none;
      font-size:22px;
      background:linear-gradient(145deg,#FFB380,#FFCC99);
      color:#fff;
      cursor:pointer;
      transition:transform 0.15s ease, box-shadow 0.15s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 4px 10px rgba(255,179,128,0.4);
    }
    .pk-react-btn:hover { transform:translateY(-2px) scale(1.05); box-shadow:0 8px 18px rgba(255,179,128,0.55); }
    .emoji-particle {
      will-change:transform, opacity;
      pointer-events:none;
      position:fixed;
      font-size:24px;
      text-shadow:0 4px 12px rgba(0,0,0,0.35);
      opacity:0;
      transform:translate3d(0,0,0) scale(0.9);
      transition:transform 1.2s cubic-bezier(.2,.9,.2,1), opacity 1.2s linear;
      z-index:10000;
    }
  </style>
</head>
<body>
  <h2 style="color:#333; text-align:center;">PK å°æˆ°</h2>
  <div id="info" style="text-align:center; color:#666; margin-bottom:10px;">æº–å‚™ä¸­â€¦</div>
  <div class="pk-container">
    <div class="pk-side">
      <h3>æˆ‘æ–¹ç•«é¢</h3>
      <video id="localVideo" autoplay muted playsinline></video>
    </div>
    <div class="pk-side">
      <h3>å°æ–¹ç•«é¢</h3>
      <video id="remoteVideo" autoplay playsinline controls></video>
    </div>
  </div>
  <!-- PK heat + reactions -->
  <div style="display:flex;gap:12px;max-width:980px;margin:12px auto;">
    <div style="flex:1;text-align:center;">
      <div id="pkLeftLabel" style="color:#333; font-weight:600; margin-bottom:4px;">æˆ‘æ–¹</div>
      <div style="height:14px;background:#f5f5f5;border-radius:8px;margin:8px 12px;overflow:hidden;border:1px solid #e0e0e0;">
        <div id="pkLeftHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#ff6b6b,#ff4081);"></div>
      </div>
      <div id="pkLeftCount" style="color:#FF6B35; font-size:20px; font-weight:700;">0</div>
    </div>
    <div style="flex:1;text-align:center;">
      <div id="pkRightLabel" style="color:#333; font-weight:600; margin-bottom:4px;">å°æ–¹</div>
      <div style="height:14px;background:#f5f5f5;border-radius:8px;margin:8px 12px;overflow:hidden;border:1px solid #e0e0e0;">
        <div id="pkRightHeat" style="height:100%;width:0%;background:linear-gradient(90deg,#42a5f5,#7c4dff);"></div>
      </div>
      <div id="pkRightCount" style="color:#42a5f5; font-size:20px; font-weight:700;">0</div>
    </div>
  </div>

  <!-- reaction buttons (broadcaster can trigger emoji too) -->
  <div style="max-width:980px;margin:6px auto;display:flex;gap:8px;justify-content:center;">
    <button class="pk-react-btn" data-type="heart">ğŸ’–</button>
    <button class="pk-react-btn" data-type="laugh">ğŸ˜„</button>
    <button class="pk-react-btn" data-type="cry">ğŸ˜¢</button>
    <button class="pk-react-btn" data-type="like">ğŸ‘</button>
  </div>
  <div id="reactionLayer" style="position:fixed; right:20px; top:80px; width:200px; height:60vh; pointer-events:none; overflow:visible; z-index:9999; display:flex; flex-direction:column; align-items:flex-end; gap:8px;"></div>
  
  <!-- chat & info area below videos -->
  <div id="pkChatArea" style="margin-top:12px; display:flex; gap:12px; align-items:flex-start;">
    <aside class="chat-area" style="flex:1; max-width:800px;">
      <div id="chatContainer">
        <div id="pkMessages" style="flex:1; overflow-y:auto; overflow-x:hidden; padding:8px; display:flex; flex-direction:column; gap:8px; box-sizing:border-box; min-height:0; max-height:280px;"></div>
        <div class="chat-input-row">
          <input id="pkChatInput" placeholder="è¼¸å…¥è¨Šæ¯...">
          <button id="pkSendBtn">é€å‡º</button>
        </div>
      </div>
    </aside>
    <div style="width:160px; text-align:center; background:#fff; padding:16px; border-radius:12px; border:1px solid #e0e0e0;">
      <div style="color:#666; font-size:14px;">åœ¨ç·šäººæ•¸</div>
      <div id="pkViewerCount" style="font-size:28px; font-weight:700; margin-top:8px; color:#FF6B35;">0</div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Basic PK page: will re-register broadcaster as owner of combined room
    const socket = io();
    const params = new URLSearchParams(window.location.search);
    const combinedRoom = params.get('room');
    const leftOwnerParam = params.get('leftOwner') || params.get('left') || null;
    const rightOwnerParam = params.get('rightOwner') || params.get('right') || null;
    if (!combinedRoom) {
      document.getElementById('info').textContent = 'éŒ¯èª¤ï¼šç¼ºå°‘åˆä½µæˆ¿é–“ç·¨è™Ÿ';
    } else {
      document.getElementById('info').textContent = `åˆä½µæˆ¿é–“ï¼š${combinedRoom}`;
      try {
        if (leftOwnerParam) document.getElementById('pkLeftLabel').textContent = String(leftOwnerParam);
        if (rightOwnerParam) document.getElementById('pkRightLabel').textContent = String(rightOwnerParam);
      } catch (e) {}
        // register as broadcaster owner for this combined room
        socket.emit('broadcaster-join', combinedRoom);
        socket.emit('join-room', combinedRoom);

        console.log('[pk-broadcaster] joined combined room', combinedRoom, 'socket', socket.id);

        // keep this combined PK room online in "ç†±é–€ç›´æ’­" by sending heartbeats
        // note: server will auto-offline a stream if no heartbeat for a period
        let __pkHeartbeatTimer = null;
        const startPkHeartbeat = () => {
          if (__pkHeartbeatTimer) return;
          __pkHeartbeatTimer = setInterval(() => {
            try {
              if (!combinedRoom) return;
              fetch('/api/heartbeat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ roomId: combinedRoom })
              }).catch(()=>{});
            } catch (e) {}
          }, 10000); // every 10s, same aså–®æˆ¿ç›´æ’­
        };
        const stopPkHeartbeat = () => { if (__pkHeartbeatTimer) { clearInterval(__pkHeartbeatTimer); __pkHeartbeatTimer = null; } };
        startPkHeartbeat();
        window.addEventListener('beforeunload', stopPkHeartbeat);

        // Keep maps for viewer peers so combined-room viewers still get the broadcaster stream
        const viewerPeers = {}; // map socketId -> RTCPeerConnection
        const viewerPendingCandidates = {};

        // PK WebRTC handshake with partner(s)
        (async function initPK() {
          try {
            const localVideo = document.getElementById('localVideo');
            const remoteVideo = document.getElementById('remoteVideo');

            const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;
            
            // è¨ºæ–·ï¼šæª¢æŸ¥éŸ³é »è»Œé“
            const audioTracks = localStream.getAudioTracks();
            const videoTracks = localStream.getVideoTracks();
            console.log(`[pk-broadcaster] localStream tracks: audio=${audioTracks.length} video=${videoTracks.length}`);
            
            // åœ¨é é¢ä¸Šé¡¯ç¤ºéŸ³é »ç‹€æ…‹
            let audioWarning = document.getElementById('audioWarning');
            if (!audioWarning) {
              audioWarning = document.createElement('div');
              audioWarning.id = 'audioWarning';
              audioWarning.style.cssText = 'position:fixed;top:60px;left:50%;transform:translateX(-50%);background:#ff5252;color:#fff;padding:12px 20px;border-radius:8px;font-weight:600;z-index:99999;display:none;';
              document.body.appendChild(audioWarning);
            }
            
            audioTracks.forEach((track, i) => {
              console.log(`[pk-broadcaster] ğŸ¤ AUDIO track ${i}: enabled=${track.enabled} muted=${track.muted} readyState=${track.readyState} label=${track.label}`);
              // ç¢ºä¿éŸ³é »è»Œé“å•Ÿç”¨
              track.enabled = true;
              
              // ç›£æ§ muted ç‹€æ…‹è®ŠåŒ–
              track.onmute = () => {
                console.warn(`[pk-broadcaster] âš ï¸ Audio track MUTED! This will cause no audio transmission.`);
                audioWarning.textContent = 'âš ï¸ éº¥å…‹é¢¨è¢«éœéŸ³ - å°æ–¹è½ä¸åˆ°è²éŸ³';
                audioWarning.style.display = 'block';
              };
              track.onunmute = () => {
                console.log(`[pk-broadcaster] âœ… Audio track UNMUTED`);
                audioWarning.style.display = 'none';
              };
              
              // åˆå§‹æª¢æŸ¥
              if (track.muted) {
                console.warn(`[pk-broadcaster] âš ï¸ Audio track is initially MUTED!`);
                audioWarning.textContent = 'âš ï¸ éº¥å…‹é¢¨éœéŸ³ä¸­ - è«‹æª¢æŸ¥æ¬Šé™';
                audioWarning.style.display = 'block';
              }
            });
            
            videoTracks.forEach((track, i) => {
              console.log(`[pk-broadcaster] ğŸ“¹ VIDEO track ${i}: enabled=${track.enabled} readyState=${track.readyState} label=${track.label}`);
            });

            const pc = new RTCPeerConnection({ 
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                { urls: 'stun:stun.stunprotocol.org:3478' },
                { urls: 'stun:stun1.stunprotocol.org:3478' },
                { urls: 'stun:stunserver.org:3478' },
                {
                  urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443', 'turn:openrelay.metered.ca:443?transport=tcp'],
                  username: 'openrelayproject',
                  credential: 'openrelayproject'
                }
              ],
              iceCandidatePoolSize: 20,
              iceTransportPolicy: 'all'
            });
            
            // ç›£æ§ PK å°æ‰‹é€£æ¥ç‹€æ…‹
            pc.onconnectionstatechange = () => {
              console.log('[pk-broadcaster] PK connection state:', pc.connectionState);
              if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                console.warn('[pk-broadcaster] âš ï¸ PK connection lost, attempting reconnect...');
                // å˜—è©¦é‡æ–°ç²å– partners
                setTimeout(() => {
                  if (combinedRoom) socket.emit('pk-get-partners', combinedRoom);
                }, 1000);
              }
            };
            // add local tracks
            const senders = [];
            localStream.getTracks().forEach(t => {
              const sender = pc.addTrack(t, localStream);
              senders.push(sender);
              const emoji = t.kind === 'audio' ? 'ğŸ¤' : 'ğŸ“¹';
              console.log(`[pk-broadcaster] ${emoji} SENT to PK partner: kind=${t.kind} enabled=${t.enabled} readyState=${t.readyState}`);
            });
            console.log(`[pk-broadcaster] âœ… Total senders to PK partner: ${senders.length}`);

            pc.ontrack = (ev) => {
              try {
                const emoji = ev.track.kind === 'audio' ? 'ğŸ¤' : 'ğŸ“¹';
                console.log(`[pk-broadcaster] ${emoji} RECEIVED from partner: kind=${ev.track.kind} enabled=${ev.track.enabled} muted=${ev.track.muted} readyState=${ev.track.readyState}`);
                
                // å¦‚æœæ”¶åˆ°çš„éŸ³é »è»Œé“æ˜¯ muted ç‹€æ…‹ï¼Œè­¦å‘Š
                if (ev.track.kind === 'audio' && ev.track.muted) {
                  console.warn(`[pk-broadcaster] âš ï¸ Partner's audio track is MUTED - you won't hear them!`);
                }
                
                if (ev.streams[0]) {
                  remoteVideo.srcObject = ev.streams[0];
                  // ç¢ºä¿ remoteVideo ä¸éœéŸ³ä»¥æ’­æ”¾å°æ–¹è²éŸ³
                  remoteVideo.muted = false;
                  remoteVideo.volume = 1.0;
                  const audioCount = ev.streams[0].getAudioTracks().length;
                  const videoCount = ev.streams[0].getVideoTracks().length;
                  console.log(`[pk-broadcaster] ğŸ“¦ Partner stream has: audio=${audioCount} video=${videoCount}`);
                  
                  // å˜—è©¦æ’­æ”¾éŸ³é »ï¼Œå¤±æ•—å‰‡éœéŸ³æ’­æ”¾
                  remoteVideo.play().then(() => {
                    console.log('[pk-broadcaster] âœ… remoteVideo playing with audio');
                  }).catch(e => {
                    console.warn('[pk-broadcaster] autoplay blocked, trying muted:', e);
                    remoteVideo.muted = true;
                    remoteVideo.play().then(() => {
                      console.log('[pk-broadcaster] âš ï¸ remoteVideo playing MUTED - click to unmute');
                      // æç¤ºä½¿ç”¨è€…
                      setTimeout(() => {
                        remoteVideo.muted = false;
                        console.log('[pk-broadcaster] ğŸ”Š Attempting to unmute after user interaction');
                      }, 1000);
                    }).catch(() => {});
                  });
                }
              } catch (e) { console.error('[pk-broadcaster] ontrack error:', e); }
            };
            // å„²å­˜å¾…ç™¼é€çš„ ICE candidates
            const pendingPkCandidates = [];
            
            pc.onicecandidate = e => {
              if (e.candidate) {
                console.log('[pk-broadcaster] ğŸ§Š ICE candidate generated:', e.candidate.type);
                // if we have a partner selected, send candidate immediately
                if (initPK._partner) {
                  socket.emit('pk-candidate', { to: initPK._partner, candidate: e.candidate });
                  console.log('[pk-broadcaster] âœ… Sent ICE candidate to partner:', initPK._partner);
                } else {
                  // store for later when partner is known
                  pendingPkCandidates.push(e.candidate);
                  console.log('[pk-broadcaster] ğŸ“¦ Stored ICE candidate (no partner yet), total:', pendingPkCandidates.length);
                }
              }
            };
            
            // è¼”åŠ©å‡½æ•¸ï¼šç•¶ partner ç¢ºå®šå¾Œç™¼é€æ‰€æœ‰å¾…ç™¼é€çš„ candidates
            const flushPendingCandidates = () => {
              if (initPK._partner && pendingPkCandidates.length > 0) {
                console.log('[pk-broadcaster] ğŸš€ Flushing', pendingPkCandidates.length, 'pending ICE candidates to', initPK._partner);
                pendingPkCandidates.forEach(candidate => {
                  socket.emit('pk-candidate', { to: initPK._partner, candidate });
                });
                pendingPkCandidates.length = 0; // clear array
              }
            };

            // Handle incoming WATCHER events: when a viewer joins (emits 'watcher'),
            // this broadcaster should also create a per-watcher offer so the viewer
            // receives this broadcaster's stream in the combined PK viewer.
            socket.on('watcher', async (id) => {
              try {
                if (!id) return;
                console.log('[pk-broadcaster] watcher seen:', id);
                
                // å¦‚æœå·²ç¶“æœ‰é€™å€‹ viewer çš„é€£æ¥ï¼Œé—œé–‰èˆŠçš„
                if (viewerPeers[id]) {
                  console.log('[pk-broadcaster] ğŸ”„ Closing old connection to viewer', id);
                  try { viewerPeers[id].close(); } catch (e) {}
                  delete viewerPeers[id];
                }
                // create a new pc for this viewer
                const vpc = new RTCPeerConnection({ 
                  iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    { urls: 'stun:stun.stunprotocol.org:3478' },
                    { urls: 'stun:stun1.stunprotocol.org:3478' },
                    { urls: 'stun:stunserver.org:3478' },
                    {
                      urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443', 'turn:openrelay.metered.ca:443?transport=tcp'],
                      username: 'openrelayproject',
                      credential: 'openrelayproject'
                    }
                  ],
                  iceCandidatePoolSize: 20,
                  iceTransportPolicy: 'all'
                });
                viewerPeers[id] = vpc;
                // add local tracks (camera/audio)
                const viewerSenders = [];
                localStream.getTracks().forEach(t => {
                  const sender = vpc.addTrack(t, localStream);
                  viewerSenders.push(sender);
                  const emoji = t.kind === 'audio' ? 'ğŸ¤' : 'ğŸ“¹';
                  console.log(`[pk-broadcaster] ${emoji} SENT to viewer ${id}: kind=${t.kind} enabled=${t.enabled} readyState=${t.readyState}`);
                });
                console.log(`[pk-broadcaster] âœ… Total senders to viewer ${id}: ${viewerSenders.length}`);

                vpc.onicecandidate = ev => {
                  if (ev.candidate) socket.emit('candidate', id, ev.candidate);
                };

                vpc.onconnectionstatechange = () => {
                  console.log('[pk-broadcaster] viewer pc state', id, vpc.connectionState);
                  if (vpc.connectionState === 'failed' || vpc.connectionState === 'closed') {
                    try { vpc.close(); } catch (e) {}
                    delete viewerPeers[id];
                  }
                };

                // if any pending candidates arrived earlier for this id, add them
                if (viewerPendingCandidates[id] && viewerPendingCandidates[id].length) {
                  for (const c of viewerPendingCandidates[id]) try { vpc.addIceCandidate(new RTCIceCandidate(c)); } catch (e) {}
                  delete viewerPendingCandidates[id];
                }

                const offer = await vpc.createOffer();
                await vpc.setLocalDescription(offer);
                // reuse the existing signaling channel: emit normal 'offer' addressed to the viewer socket id
                socket.emit('offer', id, vpc.localDescription);
                console.log('[pk-broadcaster] sent offer to viewer', id);
              } catch (e) { console.warn('pk watcher handling failed', e); }
            });

            // handle answers for viewer peers
            socket.on('answer', (id, description) => {
              try {
                const p = viewerPeers[id];
                if (p) p.setRemoteDescription(description).catch(() => {});
              } catch (e) {}
            });

            // handle ICE candidates for viewer peers
            socket.on('candidate', (id, candidate) => {
              try {
                const p = viewerPeers[id];
                if (p) p.addIceCandidate(new RTCIceCandidate(candidate)).catch(()=>{});
                else {
                  viewerPendingCandidates[id] = viewerPendingCandidates[id] || [];
                  viewerPendingCandidates[id].push(candidate);
                }
              } catch (e) {}
            });

            // ask server for partners in this combined room (delay slightly to ensure join-room processed)
            setTimeout(() => socket.emit('pk-get-partners', combinedRoom), 300);
            socket.on('pk-partners', async ({ room, partners }) => {
              try {
                // pick first partner that isn't self (if any)
                const partner = (partners && partners.length) ? partners[0] : null;
                if (!partner) {
                  // no partner connected yet; wait for incoming offer
                  console.log('PK: waiting for partner');
                  return;
                }
                // store partner id
                initPK._partner = partner;
                console.log('[pk-broadcaster] ğŸ¤ Partner set:', partner);
                // flush any pending ICE candidates
                flushPendingCandidates();
                // create offer to partner
                console.log('PK: creating offer to partner', partner);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.emit('pk-offer', { to: partner, offer: pc.localDescription });
                console.log('PK: sent offer to', partner);
              } catch (e) { console.warn('pk-partner setup failed', e); }
            });

            // incoming pk-offer
            socket.on('pk-offer', async ({ from, offer }) => {
              try {
                console.log('PK: received offer from', from);
                // set partner
                initPK._partner = from;
                console.log('[pk-broadcaster] ğŸ¤ Partner set:', from);
                // flush any pending ICE candidates
                flushPendingCandidates();
                await pc.setRemoteDescription(offer);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('pk-answer', { to: from, answer: pc.localDescription });
                console.log('PK: sent answer to', from);
              } catch (e) { console.warn('pk-offer handler failed', e); }
            });

            socket.on('pk-answer', async ({ from, answer }) => {
              try {
                console.log('PK: received answer from', from);
                await pc.setRemoteDescription(answer);
              } catch (e) { console.warn('pk-answer failed', e); }
            });

            socket.on('pk-candidate', async ({ from, candidate }) => {
              try { await pc.addIceCandidate(new RTCIceCandidate(candidate)); } catch (e) {}
            });
            
            // è™•ç† socket é‡é€£
            socket.on('reconnect', () => {
              console.log('[pk-broadcaster] ğŸ”„ Socket reconnected, re-registering...');
              if (combinedRoom) {
                socket.emit('broadcaster-join', combinedRoom);
                socket.emit('join-room', combinedRoom);
                socket.emit('broadcaster', combinedRoom);
                // é‡æ–°ç²å– PK partners
                setTimeout(() => socket.emit('pk-get-partners', combinedRoom), 500);
              }
            });
            
            socket.on('disconnect', () => {
              console.warn('[pk-broadcaster] âš ï¸ Socket disconnected');
            });

          } catch (err) {
            console.error('PK init failed', err);
          }
        })();
        
        // ç›£æ§ç¶²çµ¡ç‹€æ…‹
        window.addEventListener('online', () => {
          console.log('[pk-broadcaster] âœ… Network online');
          if (combinedRoom) {
            socket.emit('broadcaster-join', combinedRoom);
            socket.emit('join-room', combinedRoom);
            socket.emit('broadcaster', combinedRoom);
          }
        });
        window.addEventListener('offline', () => {
          console.warn('[pk-broadcaster] âš ï¸ Network offline');
        });

        // viewer count updates (for combined room)
        socket.on('viewer-count', count => {
          try { const el = document.getElementById('pkViewerCount'); if (el) el.textContent = String(count); } catch (e) {}
        });

        // handle pk votes updates to update heat bars
        socket.on('pk-votes-updated', ({ counts, total }) => {
          try {
            // left/right owners may be present in query params
            const params = new URLSearchParams(window.location.search);
            const leftOwner = params.get('left') || params.get('leftOwner') || null;
            const rightOwner = params.get('right') || params.get('rightOwner') || null;
            const leftId = leftOwner || Object.keys(counts || {})[0];
            const rightId = rightOwner || Object.keys(counts || {})[1] || Object.keys(counts || {})[0];
            const leftCount = (counts && leftId) ? (counts[leftId] || 0) : 0;
            const rightCount = (counts && rightId) ? (counts[rightId] || 0) : 0;
            const totalVal = total || (leftCount + rightCount) || 1;
            const leftPct = Math.round((leftCount / totalVal) * 100);
            const rightPct = Math.round((rightCount / totalVal) * 100);
            document.getElementById('pkLeftHeat').style.width = leftPct + '%';
            document.getElementById('pkRightHeat').style.width = rightPct + '%';
            document.getElementById('pkLeftCount').textContent = leftCount;
            document.getElementById('pkRightCount').textContent = rightCount;
          } catch (e) { console.warn('pk votes update failed', e); }
        });

        function spawnEmoji(type, opts = {}) {
          const layer = document.getElementById('reactionLayer');
          if (!layer) return;
          const emoji = document.createElement('div');
          emoji.className = 'emoji-particle';
          emoji.textContent = (type === 'heart') ? 'ğŸ’–' : (type === 'laugh') ? 'ğŸ˜„' : (type === 'cry') ? 'ğŸ˜¢' : 'ğŸ‘';
          const ref = document.getElementById('remoteVideo') || document.getElementById('localVideo');
          let startX, startY;
          if (opts.x !== undefined) {
            startX = opts.x;
            startY = opts.y !== undefined ? opts.y : (window.innerHeight * 0.6);
          } else if (ref && typeof ref.getBoundingClientRect === 'function') {
            const r = ref.getBoundingClientRect();
            startX = r.right - 36 + (Math.random() - 0.5) * 28;
            startY = r.top + 24 + (Math.random() - 0.5) * 24;
          } else {
            startX = (window.innerWidth * 0.7) + (Math.random() - 0.5) * 120;
            startY = (window.innerHeight * 0.5) + (Math.random() - 0.5) * 80;
          }
          emoji.style.left = `${startX}px`;
          emoji.style.top = `${startY}px`;
          emoji.style.fontSize = `${opts.size || (18 + Math.random() * 18)}px`;
          emoji.style.opacity = '1';
          layer.appendChild(emoji);
          requestAnimationFrame(() => {
            const dx = (Math.random() - 0.5) * 55;
            const dy = - (200 + Math.random() * 140);
            const rot = (Math.random() - 0.5) * 40;
            emoji.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) scale(1.05)`;
            emoji.style.opacity = '0';
          });
          setTimeout(() => { try { layer.removeChild(emoji); } catch (e) {} }, 1300);
        }

        // broadcaster reaction buttons (PK-specific)
        document.querySelectorAll('.pk-react-btn').forEach(b => {
          b.addEventListener('click', () => {
            const t = b.dataset.type;
            if (!combinedRoom) return;
            socket.emit('pk-emoji', { roomId: combinedRoom, type: t });
            try { spawnEmoji(t, { size: 20 + Math.random() * 24 }); } catch (e) {}
          });
        });

        socket.on('pk-emoji', data => {
          try { spawnEmoji(data.type, { size: 18 + Math.random() * 20 }); } catch (e) {}
        });

        // Chat handling for PK broadcaster page (send/receive to combinedRoom)
        // deterministic pastel-ish color generator based on userId (or username fallback)
        function colorForId(id) {
          if (!id) id = 'anon';
          let h = 0;
          for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
          const hue = Math.abs(h) % 360;
          const sat = 68;
          const light = 58;
          return `hsl(${hue} ${sat}% ${light}%)`;
        }

        function appendPkChatMessage(data, options = {}) {
          try {
            if (!data) return;
            // allow passing local-sent short objects without roomId
            if (data.roomId && data.roomId !== combinedRoom) return;
            const box = document.getElementById('pkMessages');
            const line = document.createElement('div');
            line.style.padding = '6px 0';
            const name = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
            // highlight local messages slightly
            const bg = options.local ? 'rgba(255,255,255,0.02)' : 'transparent';
            line.style.background = bg;
            const idForColor = data.userId || data.sender || data.user || 'anon';
            const nameColor = colorForId(String(idForColor));
            const avatar = data.avatar || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Crect fill="%23e0e0e0" width="200" height="200"/%3E%3Ccircle cx="100" cy="70" r="40" fill="%23999"/%3E%3Cellipse cx="100" cy="150" rx="50" ry="40" fill="%23999"/%3E%3C/svg%3E';
            const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
            line.innerHTML = `<img src="${avatar}" alt="avatar" style="width:36px;height:36px;border-radius:6px;object-fit:cover;vertical-align:middle;margin-right:8px;">` +
                             `<div class="text" style="display:inline-block;vertical-align:middle;"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
            box.appendChild(line);
            while (box.children.length > 80) box.removeChild(box.firstChild);
            box.scrollTop = box.scrollHeight;
          } catch (e) { console.warn('appendPkChatMessage failed', e); }
        }

        socket.on('chat-message', data => {
          console.log('[pk-broadcaster] chat-message received', data);
          appendPkChatMessage(data);
        });

        socket.on('system-message', text => {
          try { const box = document.getElementById('pkMessages'); const el = document.createElement('div'); el.style.opacity = '0.9'; el.style.padding='6px 0'; el.style.color='#9e9e9e'; el.textContent = text; box.appendChild(el); while (box.children.length>80) box.removeChild(box.firstChild); box.scrollTop = box.scrollHeight; } catch (e) {}
        });

        // Chat send behavior: reuse viewer.html logic so Enter and button both send, and use real profile
        let pkUsername = 'ä¸»æ’­';
        let pkAvatar = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Crect fill="%23e0e0e0" width="200" height="200"/%3E%3Ccircle cx="100" cy="70" r="40" fill="%23999"/%3E%3Cellipse cx="100" cy="150" rx="50" ry="40" fill="%23999"/%3E%3C/svg%3E';
        let pkUserId = null;

        function pkSendMessage() {
          const input = document.getElementById('pkChatInput');
          const text = input.value.trim();
          if (!text) return;
          const payload = { roomId: combinedRoom, user: pkUsername, userId: pkUserId, text, avatar: pkAvatar, isHost: true };
          console.log('[pk-broadcaster] sending chat-message', payload);
          // append locally immediately so sender sees their message even if server echo is delayed
          appendPkChatMessage(payload, { local: true });
          socket.emit('chat-message', payload);
          input.value = '';
        }

        const pkSendBtnEl = document.getElementById('pkSendBtn');
        pkSendBtnEl.onclick = pkSendMessage;
        // use keydown for more reliable Enter capture
        document.getElementById('pkChatInput').addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); pkSendMessage(); }
        });

        // disable until profile loaded
        pkSendBtnEl.disabled = true;
        fetch('/api/profile', { credentials: 'include' })
          .then(res => res.ok ? res.json() : null)
          .then(data => {
            if (data) {
              pkUsername = data.username || pkUsername;
              pkAvatar = data.avatar || pkAvatar;
              pkUserId = data.id || null;
            }
          })
          .catch(() => {})
          .finally(() => { pkSendBtnEl.disabled = false; });

    }
  </script>
</body>
</html>
