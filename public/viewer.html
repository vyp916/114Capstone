<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>è§€çœ‹ç›´æ’­</title>
  <link rel="stylesheet" href="style-modern.css">

</head>
<body>
  <div class="viewer-layout">
    <div class="viewer-area">
      <div class="viewer-container">
        <div id="infoBar" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:6px;">
          <span>æˆ¿é–“è™Ÿï¼š<strong id="roomCode">---</strong></span>
          <span>ğŸ‘¥ åœ¨ç·šäººæ•¸ï¼š<strong id="viewerCount">0</strong></span>
          <button id="shareBtn" style="padding:6px 10px;border-radius:6px;border:1px solid #444;background:#111;color:#eee;cursor:pointer;">ğŸ“¤ åˆ†äº«é€£çµ</button>
        </div>
        <h2 id="streamTitle">è¼‰å…¥ä¸­...</h2>
        <p id="streamDesc"></p>
          <video id="video" autoplay playsinline controls muted></video>
          <button id="unmuteBtn" style="position:absolute; right:16px; bottom:16px; z-index:999; padding:8px 10px; border-radius:6px; background:#222;color:#fff;border:none;display:none;">è§£é™¤éœéŸ³ ğŸ”Š</button>
          <div id="audioHint" style="position:absolute; left:16px; bottom:16px; z-index:999; padding:6px 10px; border-radius:6px; background:rgba(0,0,0,0.65); color:#fff; font-size:12px; display:none;">
            è‹¥æ²’è²éŸ³ï¼Œé»ã€Œè§£é™¤éœéŸ³ã€ï¼Œæˆ–ç¢ºèªéº¥å…‹é¢¨æœ‰å‚³å…¥
          </div>
          <!-- reactions (moved to PK pages) -->
            <!-- === Reactions (æ¢å¾©é PK è§€çœ‹ç«¯äº’å‹•) === -->
            <div id="reactionBar" style="margin:10px 0 4px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <button class="react-btn" data-type="heart" title="é€å‡º ğŸ’–">ğŸ’–</button>
              <button class="react-btn" data-type="laugh" title="é€å‡º ğŸ˜„">ğŸ˜„</button>
              <button class="react-btn" data-type="cry" title="é€å‡º ğŸ˜¢">ğŸ˜¢</button>
              <button class="react-btn" data-type="like" title="é€å‡º ğŸ‘">ğŸ‘</button>
              <button id="reactionValve" style="padding:6px 14px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:13px;cursor:pointer;">ğŸ” å‹•ç•«: é–‹å•Ÿ</button>
              <button id="reactionReselect" style="padding:6px 14px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:13px;cursor:pointer;">ğŸ¯ é‡é¸è¡¨æƒ…</button>
              <span id="topReaction" style="margin-left:auto;font-size:14px;color:#ffd2e6;"></span>
            </div>
            <div id="reactionLayer" style="position:fixed; right:20px; bottom:100px; width:160px; height:50vh; pointer-events:none; overflow:visible; z-index:9999;"></div>
            <style>
              .react-btn { width:52px;height:52px;border-radius:50%;border:none;font-size:24px;cursor:pointer;background:#222;color:#fff;box-shadow:0 4px 10px rgba(0,0,0,.45);transition:transform .15s, box-shadow .15s; }
              .react-btn:hover { transform:translateY(-3px) scale(1.06); box-shadow:0 8px 18px rgba(0,0,0,.55); }
              .react-btn:disabled { filter:grayscale(70%); opacity:.55; cursor:not-allowed; }
              #reactionValve.off { background:#300; color:#f88; }
              .emoji-particle { position:fixed; font-size:20px; opacity:0; transform:translate3d(0,0,0) scale(.9); transition:transform 1.1s cubic-bezier(.2,.9,.2,1), opacity 1.1s linear; will-change:transform,opacity; pointer-events:none; }
            </style>
        <p id="roomInfo"></p>
        <a href="index.html">è¿”å›é¦–é </a>
      </div>
    </div>

    <aside class="chat-area">
      <div id="chatContainer">
        <div id="messages"></div>
        <div class="chat-input-row">
          <input id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯...">
          <button id="sendBtn" disabled>é€å‡º</button>
        </div>
      </div>
    </aside>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    // debug helpers: connection state
    socket.on('connect', () => console.log('[viewer] socket connected', socket.id));
    socket.on('connect_error', (err) => console.warn('[viewer] socket connect_error', err && err.message));
    const params = new URLSearchParams(window.location.search);
    const roomId = params.get('room');
  // é¡¯ç¤ºæˆ¿é–“è™Ÿ
  try { const rc = document.getElementById('roomCode'); if (rc) rc.textContent = roomId || '---'; } catch (e) {}
  let username = 'åŒ¿åç”¨æˆ¶';
  let avatar = '/uploads/default_avatar.png';
  let userId = null; // deterministic id for coloring chat names (from /api/profile)

    // ç­‰å¾… socket é€£ç·šå®Œæˆå¾Œæ‰ç™¼é€ viewer-ready
    function notifyViewerReady() {
      if (socket.id) {
        socket.emit('join-room', roomId);
        socket.emit('viewer-ready', { roomId, viewerId: socket.id });
        console.log('[Viewer] emitted viewer-ready for room', roomId, 'with viewerId', socket.id);
      } else {
        console.warn('[Viewer] socket.id not ready yet, retrying...');
        setTimeout(notifyViewerReady, 100);
      }
    }
    
    // å¦‚æœå·²ç¶“é€£ç·šå°±ç«‹å³ç™¼é€ï¼Œå¦å‰‡ç­‰å¾… connect äº‹ä»¶
    if (socket.connected && socket.id) {
      notifyViewerReady();
    } else {
      socket.on('connect', notifyViewerReady);
    }
    
    // åœ¨ç·šäººæ•¸æ›´æ–°
    socket.on('viewer-count', count => {
      try { const vc = document.getElementById('viewerCount'); if (vc) vc.textContent = String(count); } catch (e) {}
    });

    // åˆ†äº«é€£çµæŒ‰éˆ•
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        const url = `${window.location.origin}/viewer.html?room=${encodeURIComponent(roomId || '')}`;
        navigator.clipboard.writeText(url).then(() => {
          alert(`ğŸ“ å·²è¤‡è£½åˆ†äº«é€£çµï¼š\n${url}`);
        }).catch(() => {
          alert('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹æ‰‹å‹•è¤‡è£½ï¼š\n' + url);
        });
      };
    }
    
    // ç›£è½ broadcaster äº‹ä»¶ï¼ˆä¿æŒç›¸å®¹æ€§ï¼‰
    socket.on('broadcaster', (data) => {
      console.log('[Viewer] broadcaster detected in room', data);
      // broadcaster å·²åœ¨ç·šï¼Œå†æ¬¡é€šçŸ¥æº–å‚™æ¥æ”¶
      if (socket.id) {
        socket.emit('viewer-ready', { roomId, viewerId: socket.id });
        console.log('[Viewer] re-emitted viewer-ready after broadcaster announcement');
      }
    });

  // æ¥æ”¶è¨Šæ¯ ï¼ˆä½¿ç”¨ userId ç”¢ç”Ÿ identity colorï¼‰
    // deterministic pastel-ish color generator based on userId (or username fallback)
    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
  const idForColor = data.userId || data.sender || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar">
                      <div class="text"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

  // Signaling events (kept silent in production)
  socket.on('offer', () => {});
  socket.on('answer', () => {});
  socket.on('candidate', () => {});

    // ç³»çµ±è¨Šæ¯
    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // If server tells this viewer the room has merged for PK, redirect to pk-viewer
    socket.on('pk-merged', ({ combinedRoom, leftOwner, rightOwner }) => {
      try {
        console.log('[viewer] received pk-merged', combinedRoom, leftOwner, rightOwner);
        if (!combinedRoom) return;
        const qs = new URLSearchParams({ room: combinedRoom });
        if (leftOwner) qs.set('leftOwner', String(leftOwner));
        if (rightOwner) qs.set('rightOwner', String(rightOwner));
        window.location.href = `/pk-viewer.html?${qs.toString()}`;
      } catch (e) { console.warn('pk-merged redirect failed', e); }
    });

    // reactions removed from normal viewer; PK pages now provide emoji UI
      // === æ™®é€šè§€çœ‹é é¢ Reactions åŠŸèƒ½ ===
      let showEmoji = true;   // é–¥é–€ï¼šæ§åˆ¶æ˜¯å¦é¡¯ç¤ºæœ¬åœ°å‹•ç•«
      let reacted = false;    // æ˜¯å¦å·²é€å‡ºéç¬¬ä¸€æ¬¡åæ‡‰ï¼ˆçµ±è¨ˆåªè¨˜ä¸€æ¬¡ï¼‰
      const valveBtn = document.getElementById('reactionValve');
    const reselectBtn = document.getElementById('reactionReselect');
    let reselectMode = false; // é‡é¸æ¨¡å¼ï¼šä¸‹ä¸€æ¬¡é»æ“Šè¡¨æƒ…å°‡é€å‡º reaction-change

      function spawnEmoji(type, opts = {}) {
        if (!showEmoji) return; // é–¥é–€é—œé–‰ä»å¯çµ±è¨ˆï¼Œä½†ä¸é¡¯ç¤ºå‹•ç•«
        const layer = document.getElementById('reactionLayer');
        if (!layer) return;
        const el = document.createElement('div');
        el.className = 'emoji-particle';
        el.textContent = (type === 'heart') ? 'ğŸ’–' : (type === 'laugh') ? 'ğŸ˜„' : (type === 'cry') ? 'ğŸ˜¢' : 'ğŸ‘';
        const ref = document.getElementById('video');
        let startX, startY;
        if (ref && typeof ref.getBoundingClientRect === 'function') {
          const r = ref.getBoundingClientRect();
          startX = r.right - 36 + (Math.random() - 0.5) * 30;
          startY = r.bottom - 22 + (Math.random() - 0.5) * 16;
        } else {
          startX = window.innerWidth * 0.75 + (Math.random() - 0.5) * 120;
          startY = window.innerHeight * 0.6 + (Math.random() - 0.5) * 100;
        }
        el.style.left = startX + 'px';
        el.style.top = startY + 'px';
        el.style.fontSize = (opts.size || (18 + Math.random() * 16)) + 'px';
        el.style.opacity = '1';
        document.body.appendChild(el);
        requestAnimationFrame(() => {
          const dx = (Math.random() - 0.5) * 50;
          const dy = - (190 + Math.random() * 140);
          const rot = (Math.random() - 0.5) * 40;
          el.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) scale(1.05)`;
          el.style.opacity = '0';
        });
        setTimeout(() => { try { el.remove(); } catch (e) {} }, 1150);
      }

      if (valveBtn) {
        valveBtn.addEventListener('click', () => {
          showEmoji = !showEmoji;
          valveBtn.classList.toggle('off', !showEmoji);
          valveBtn.textContent = showEmoji ? 'ğŸ” å‹•ç•«: é–‹å•Ÿ' : 'ğŸ” å‹•ç•«: é—œé–‰';
        });
      }

      if (reselectBtn) {
        reselectBtn.addEventListener('click', () => {
          reselectMode = true;
          reselectBtn.textContent = 'ğŸ¯ é‡é¸ä¸­â€¦';
          reselectBtn.disabled = true;
          // 5 ç§’å¾Œè‡ªå‹•é€€å‡ºé‡é¸æ¨¡å¼ï¼ˆé¿å…å¿˜è¨˜é»ï¼‰
          setTimeout(() => { if (reselectMode) { reselectMode = false; reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; } }, 5000);
        });
      }

      // æ›´æ–°ç†±é–€åæ‡‰çµ±è¨ˆ
      socket.on('reaction-stats', stats => {
        const el = document.getElementById('topReaction');
        if (!el) return;
        if (!stats || !stats.topType) { el.textContent = ''; return; }
        const emojiMap = { heart: 'ğŸ’–', laugh: 'ğŸ˜„', cry: 'ğŸ˜¢', like: 'ğŸ‘' };
        const e = emojiMap[stats.topType] || stats.topType;
        el.textContent = `${e} ${stats.topCount}`;
      });

      // æ¥æ”¶ä»–äººåæ‡‰å‹•ç•«ï¼ˆä¸å½±éŸ¿çµ±è¨ˆï¼‰
      socket.on('reaction', ({ type }) => { spawnEmoji(type); });

      // ç¶å®šæŒ‰éˆ•é€å‡º reactionï¼šæ¯æ¬¡éƒ½é€äº‹ä»¶ä»¥é¡¯ç¤ºå‹•ç•«ï¼›çµ±è¨ˆåƒ…è¨˜ç¬¬ä¸€æ¬¡
      document.querySelectorAll('.react-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const type = btn.dataset.type;
          if (!roomId || !type) return;
          // æ¯æ¬¡éƒ½é€å‡ºäº‹ä»¶ï¼Œè®“æ‰€æœ‰äººçœ‹åˆ°å‹•ç•«ï¼›ä¼ºæœå™¨åªæœƒåœ¨ç¬¬ä¸€æ¬¡è¨ˆå…¥çµ±è¨ˆ
          if (reselectMode) {
            socket.emit('reaction-change', { roomId, type });
            reselectMode = false;
            if (reselectBtn) { reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; }
          } else {
            socket.emit('reaction', { roomId, type });
            if (!reacted) reacted = true; // æ¨™è¨˜å·²åæ‡‰éä¸€æ¬¡
          }
          spawnEmoji(type, { size: 20 + Math.random() * 14 });
        });
      });
    // (ä¸Šæ–¹å·²æ¢å¾©æ™®é€šç›´æ’­çš„ reaction UI)

  const sendBtn = document.getElementById('sendBtn');
    // å‚³é€è¨Šæ¯åŠŸèƒ½
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId, user: username, userId, text, avatar });
      input.value = '';
    }

    // ç¶å®šé€å‡ºæŒ‰éˆ•
    document.getElementById('sendBtn').onclick = sendMessage;
    
    // ç¶å®š Enter éµ
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // é˜²æ­¢æ›è¡Œ
        sendMessage();
      }
    });



    // å…ˆç¦ç”¨é€å‡ºæŒ‰éˆ•ï¼Œç­‰ profile è¼‰å…¥æˆ–ç¢ºèªå¾Œå†å•Ÿç”¨ï¼ˆé¿å…é‚„æ²’è¼‰å…¥ username å°±é€å‡ºè¨Šæ¯ï¼‰
    sendBtn.disabled = true;
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) {
          username = data.username;
          avatar = data.avatar || '/uploads/default_avatar.png';
          userId = data.id || null;
        }
      })
      .catch(() => {})
      .finally(() => {
        // ç„¡è«–æ˜¯å¦ç™»å…¥ï¼Œéƒ½å…è¨±ä½¿ç”¨è€…é€å‡ºï¼ˆè‹¥æœªç™»å…¥å‰‡ä»ç‚ºåŒ¿åï¼‰
        sendBtn.disabled = false;
      });


    // é¡¯ç¤ºç›´æ’­è³‡è¨Š
    fetch(`/api/stream-info?room=${roomId}`)
      .then(res => res.json())
      .then(info => {
        document.getElementById('streamTitle').textContent = info.title;
        document.getElementById('streamDesc').textContent = info.description;
        document.getElementById('roomInfo').textContent = `æˆ¿é–“è™Ÿï¼š${roomId} | ä¸»æ’­ï¼š${info.username}`;
    });

      // reactions removed from normal viewer; use PK pages for emoji interactions

  // è§€çœ‹ç«¯ WebRTC - support multiple broadcasters (map by id) and handle duplicate offers
  const video = document.getElementById('video');
  const config = { 
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" },
      { urls: "stun:stun2.l.google.com:19302" },
      {
        urls: "turn:openrelay.metered.ca:80",
        username: "openrelayproject",
        credential: "openrelayproject"
      },
      {
        urls: "turn:openrelay.metered.ca:443",
        username: "openrelayproject",
        credential: "openrelayproject"
      },
      {
        urls: "turn:openrelay.metered.ca:443?transport=tcp",
        username: "openrelayproject",
        credential: "openrelayproject"
      }
    ],
    iceCandidatePoolSize: 10
  };
  const peers = {}; // map of RTCPeerConnection by broadcaster socket id
  const pendingCandidates = {}; // store candidates that arrive before pc is created
  let userUnmuted = false; // ä½¿ç”¨è€…æ˜¯å¦å·²æ‰‹å‹•è§£é™¤éœéŸ³ï¼ˆé¿å…å¾ŒçºŒ ontrack æŠŠ muted æ”¹å›å»ï¼‰
  // ä¸å†ä½¿ç”¨èˆŠçš„ watcher æ©Ÿåˆ¶ï¼Œå·²æ”¹ç”¨ viewer-ready

    socket.on("offer", async (id, description) => {
      console.log('[Viewer] â¬‡ï¸ received offer from broadcaster', id);
      try {
        // if an existing pc exists for this id, close it to avoid state conflicts
        if (peers[id]) {
          console.log('[Viewer] closing existing peer for', id);
          try { peers[id].close(); } catch (e) {}
          delete peers[id];
          // clear video preview if it was attached to old pc
          try { if (video.srcObject) video.srcObject = null; } catch (e) {}
        }

        console.log('[Viewer] creating new RTCPeerConnection');
        const pc = new RTCPeerConnection(config);
        peers[id] = pc;

        pc.ontrack = event => {
          try {
            // åƒ…åœ¨å°šæœªæ‰‹å‹•è§£é™¤éœéŸ³æ™‚é è¨­éœéŸ³ï¼Œé¿å…å¾ŒçºŒ ontrack è¦†è“‹ä½¿ç”¨è€…é¸æ“‡
            if (!userUnmuted) video.muted = true;
            video.srcObject = event.streams[0];
            video.play().catch(() => {});
            // Debug: log incoming tracks
            try {
              const audios = event.streams[0] && event.streams[0].getAudioTracks ? event.streams[0].getAudioTracks() : [];
              const videos = event.streams[0] && event.streams[0].getVideoTracks ? event.streams[0].getVideoTracks() : [];
              console.log('[Viewer] ontrack audio:', audios.length, audios.map(a => ({ label: a.label, enabled: a.enabled, muted: a.muted })), 'video:', videos.length);
            } catch (e) { console.warn('[Viewer] log tracks failed', e); }

            // ä¸è«–æ˜¯å¦ç«‹å³åµæ¸¬åˆ°éŸ³è»Œï¼Œéƒ½è®“ä½¿ç”¨è€…å¯æŒ‰ä¸‹è§£é™¤éœéŸ³ï¼›ä¸¦å†æ¬¡æª¢æŸ¥éŸ³è»Œç‹€æ…‹
            const unmuteBtn = document.getElementById('unmuteBtn');
            if (unmuteBtn) {
              unmuteBtn.style.display = 'block';
              unmuteBtn.onclick = () => {
                try {
                  video.muted = false;
                  video.volume = 1.0;
                  // å¼·åˆ¶å•Ÿç”¨æ‰€æœ‰éŸ³è¨Š tracksï¼ˆå³ä½¿ track.muted æ˜¯å”¯è®€ï¼Œenabled å¯æ”¹ï¼‰
                  const stream = video.srcObject;
                  if (stream && stream.getAudioTracks) {
                    stream.getAudioTracks().forEach(track => {
                      track.enabled = true;
                      console.log('[Viewer] enabled audio track:', track.label);
                    });
                  }
                  video.play().then(() => {
                    console.log('[Viewer] video playing, muted:', video.muted, 'volume:', video.volume);
                    // å˜—è©¦è§¸ç™¼ video controls çš„éœéŸ³æŒ‰éˆ•ä»¥åŒæ­¥ UIï¼ˆç°è‰²å–‡å­å•é¡Œï¼‰
                    setTimeout(() => {
                      try {
                        // å†æ¬¡ç¢ºä¿ muted ç‚º false
                        if (video.muted) {
                          video.muted = false;
                          console.log('[Viewer] re-applied muted=false');
                        }
                      } catch (e) {}
                    }, 100);
                  }).catch(err => {
                    console.warn('[Viewer] play failed:', err);
                  });
                  unmuteBtn.style.display = 'none';
                  userUnmuted = true;
                } catch (e) {
                  console.error('[Viewer] unmute failed:', e);
                }
              };
              // 500ms å¾Œé‡æ–°æª¢æŸ¥æ˜¯å¦å­˜åœ¨éŸ³è»Œï¼Œè‹¥æœ‰å‰‡ä¿æŒæŒ‰éˆ•å¯ç”¨
              setTimeout(() => {
                try {
                  const s = video.srcObject;
                  const hasAudioLater = s && s.getAudioTracks && s.getAudioTracks().length > 0;
                  if (hasAudioLater) {
                    unmuteBtn.style.display = 'block';
                  }
                } catch (e) {}
              }, 500);
            }
          } catch (e) {}
        };

        pc.onicecandidate = evt => {
          if (evt.candidate) socket.emit('candidate', id, evt.candidate);
        };

        // if candidates arrived earlier, add them now
        if (pendingCandidates[id] && pendingCandidates[id].length) {
          pendingCandidates[id].forEach(c => pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}));
          delete pendingCandidates[id];
        }

        console.log('[Viewer] setting remote description');
        await pc.setRemoteDescription(description);
        console.log('[Viewer] creating answer');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        console.log('[Viewer] sending answer to', id);
        socket.emit('answer', id, pc.localDescription);
      } catch (err) {
        console.error('[Viewer] âŒ Error handling offer:', err);
      }
    });

    socket.on('candidate', (id, candidate) => {
      const pc = peers[id];
      if (pc) {
        console.log('[Viewer] adding ICE candidate from', id);
        pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(err => {
          console.warn('[Viewer] failed to add ICE candidate:', err);
        });
      } else {
        console.log('[Viewer] storing ICE candidate for future peer', id);
        pendingCandidates[id] = pendingCandidates[id] || [];
        pendingCandidates[id].push(candidate);
      }
    });
  </script>
</body>
</html>
