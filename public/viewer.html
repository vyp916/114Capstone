<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>è§€çœ‹ç›´æ’­</title>
  <link rel="stylesheet" href="style-modern.css">

</head>
<body>
  <div class="viewer-layout">
    <div class="viewer-area">
      <div class="viewer-container">
        <div id="infoBar" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:6px;">
          <span>æˆ¿é–“è™Ÿï¼š<strong id="roomCode">---</strong></span>
          <span>ğŸ‘¥ åœ¨ç·šäººæ•¸ï¼š<strong id="viewerCount">0</strong></span>
          <button id="shareBtn" style="padding:6px 10px;border-radius:6px;border:1px solid #444;background:#111;color:#eee;cursor:pointer;">ğŸ“¤ åˆ†äº«é€£çµ</button>
          <button id="diagBtn" style="margin-left:6px;padding:4px 8px;font-size:12px;">ğŸ”§ è¨ºæ–·é¢æ¿</button>
        </div>

        <!-- è¨ºæ–·é¢æ¿ -->
        <div id="diagPanel" style="display:none;background:#1a1a1a;color:#0f0;border:1px solid #0f0;border-radius:6px;padding:12px;margin:8px;font-family:monospace;font-size:11px;max-height:200px;overflow:auto;box-shadow:0 0 10px rgba(0,255,0,0.3);">
          <div style="display:flex;justify-content:space-between;margin-bottom:8px;border-bottom:1px solid #0f0;padding-bottom:8px;">
            <strong>ğŸ”§ WebRTC è¨ºæ–·</strong>
            <button id="closeDiagBtn" style="background:#0f0;color:#1a1a1a;border:none;padding:2px 6px;cursor:pointer;font-weight:bold;">é—œ</button>
          </div>
          <div id="diagContent" style="line-height:1.6;">
            <div>é€£ç·šç‹€æ…‹ï¼š<span id="connStatus">---</span></div>
            <div>ICE ç‹€æ…‹ï¼š<span id="iceStatus">---</span></div>
            <div>ç°½ç½²ç‹€æ…‹ï¼š<span id="sigStatus">---</span></div>
            <div>å·²æ¥æ”¶å€™é¸ï¼š<span id="candCount">0</span> <span style="color:#888;">(Host/Srflx/Relay)</span></div>
            <div style="margin-top:6px;padding-top:6px;border-top:1px solid #333;">
              <div style="color:#888;font-size:10px;">Relay å€™é¸ï¼š<span id="relayCands">âŒ æœªç™¼ç¾</span></div>
              <div style="color:#888;font-size:10px;">TURN ä¼ºæœå™¨ï¼š<span id="turnServer">---</span></div>
            </div>
          </div>
        </div>
        <h2 id="streamTitle">è¼‰å…¥ä¸­...</h2>
        <p id="streamDesc"></p>
          <video id="video" autoplay playsinline controls></video>
          <!-- reactions (moved to PK pages) -->
            <!-- === Reactions (æ¢å¾©é PK è§€çœ‹ç«¯äº’å‹•) === -->
            <div id="reactionBar" style="margin:10px 0 4px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <button class="react-btn" data-type="heart" title="é€å‡º ğŸ’–">ğŸ’–</button>
              <button class="react-btn" data-type="laugh" title="é€å‡º ğŸ˜„">ğŸ˜„</button>
              <button class="react-btn" data-type="cry" title="é€å‡º ğŸ˜¢">ğŸ˜¢</button>
              <button class="react-btn" data-type="like" title="é€å‡º ğŸ‘">ğŸ‘</button>
              <button id="reactionValve" style="padding:6px 14px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:13px;cursor:pointer;">ğŸ” å‹•ç•«: é–‹å•Ÿ</button>
              <button id="reactionReselect" style="padding:6px 14px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:13px;cursor:pointer;">ğŸ¯ é‡é¸è¡¨æƒ…</button>
              <span id="topReaction" style="margin-left:auto;font-size:14px;color:#ffd2e6;"></span>
            </div>
            <div id="reactionLayer" style="position:fixed; right:20px; bottom:100px; width:160px; height:50vh; pointer-events:none; overflow:visible; z-index:9999;"></div>
            <style>
              .react-btn { width:52px;height:52px;border-radius:50%;border:none;font-size:24px;cursor:pointer;background:#222;color:#fff;box-shadow:0 4px 10px rgba(0,0,0,.45);transition:transform .15s, box-shadow .15s; }
              .react-btn:hover { transform:translateY(-3px) scale(1.06); box-shadow:0 8px 18px rgba(0,0,0,.55); }
              .react-btn:disabled { filter:grayscale(70%); opacity:.55; cursor:not-allowed; }
              #reactionValve.off { background:#300; color:#f88; }
              .emoji-particle { position:fixed; font-size:20px; opacity:0; transform:translate3d(0,0,0) scale(.9); transition:transform 1.1s cubic-bezier(.2,.9,.2,1), opacity 1.1s linear; will-change:transform,opacity; pointer-events:none; }
            </style>
        <p id="roomInfo"></p>
        <a href="index.html">è¿”å›é¦–é </a>
      </div>
    </div>

    <aside class="chat-area">
      <div id="chatContainer">
        <div id="messages"></div>
        <div class="chat-input-row">
          <input id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯...">
          <button id="sendBtn" disabled>é€å‡º</button>
        </div>
      </div>
    </aside>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // è¨ºæ–·é¢æ¿æ›´æ–°å‡½æ•¸
    function updateDiagPanel(pc, candCount, hasRelay, relayServer) {
      document.getElementById('connStatus').textContent = pc?.connectionState || '---';
      document.getElementById('iceStatus').textContent = pc?.iceConnectionState || '---';
      document.getElementById('sigStatus').textContent = pc?.signalingState || '---';
      
      const totalCands = (candCount.host || 0) + (candCount.srflx || 0) + (candCount.relay || 0);
      document.getElementById('candCount').textContent = `${totalCands} (${candCount.host || 0}H/${candCount.srflx || 0}S/${candCount.relay || 0}R)`;
      
      if (hasRelay) {
        document.getElementById('relayCands').innerHTML = `âœ… å·²ç™¼ç¾ (${relayServer || 'æœªçŸ¥'})`;
        document.getElementById('relayCands').style.color = '#00ff00';
      } else {
        document.getElementById('relayCands').innerHTML = 'âŒ æœªç™¼ç¾';
        document.getElementById('relayCands').style.color = '#ff6b6b';
      }
    }

    // è¨ºæ–·é¢æ¿é–‹é—œ
    document.getElementById('diagBtn').addEventListener('click', () => {
      const panel = document.getElementById('diagPanel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    });
    
    document.getElementById('closeDiagBtn')?.addEventListener('click', () => {
      document.getElementById('diagPanel').style.display = 'none';
    });

    const socket = io();
    // debug helpers: connection state
    socket.on('connect', () => console.log('[viewer] socket connected', socket.id));
    socket.on('connect_error', (err) => console.warn('[viewer] socket connect_error', err && err.message));
    const params = new URLSearchParams(window.location.search);
    const roomId = params.get('room');
  // é¡¯ç¤ºæˆ¿é–“è™Ÿ
  try { const rc = document.getElementById('roomCode'); if (rc) rc.textContent = roomId || '---'; } catch (e) {}
  let username = 'åŒ¿åç”¨æˆ¶';
  let avatar = '/uploads/default_avatar.png';
  let userId = null; // deterministic id for coloring chat names (from /api/profile)

    // ç­‰å¾… socket é€£ç·šå®Œæˆå¾Œæ‰ç™¼é€ viewer-ready
    function notifyViewerReady() {
      if (socket.id) {
        socket.emit('join-room', roomId);
        socket.emit('viewer-ready', { roomId, viewerId: socket.id });
        console.log('[Viewer] emitted viewer-ready for room', roomId, 'with viewerId', socket.id);
      } else {
        console.warn('[Viewer] socket.id not ready yet, retrying...');
        setTimeout(notifyViewerReady, 100);
      }
    }
    
    // å¦‚æœå·²ç¶“é€£ç·šå°±ç«‹å³ç™¼é€ï¼Œå¦å‰‡ç­‰å¾… connect äº‹ä»¶
    if (socket.connected && socket.id) {
      notifyViewerReady();
    } else {
      socket.on('connect', notifyViewerReady);
    }
    
    // åœ¨ç·šäººæ•¸æ›´æ–°
    socket.on('viewer-count', count => {
      try { const vc = document.getElementById('viewerCount'); if (vc) vc.textContent = String(count); } catch (e) {}
    });

    // åˆ†äº«é€£çµæŒ‰éˆ•
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        const url = `${window.location.origin}/viewer.html?room=${encodeURIComponent(roomId || '')}`;
        navigator.clipboard.writeText(url).then(() => {
          alert(`ğŸ“ å·²è¤‡è£½åˆ†äº«é€£çµï¼š\n${url}`);
        }).catch(() => {
          alert('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹æ‰‹å‹•è¤‡è£½ï¼š\n' + url);
        });
      };
    }
    
    // ç›£è½ broadcaster äº‹ä»¶ï¼ˆä¿æŒç›¸å®¹æ€§ï¼‰
    socket.on('broadcaster', (data) => {
      console.log('[Viewer] broadcaster detected in room', data);
      // broadcaster å·²åœ¨ç·šï¼Œå†æ¬¡é€šçŸ¥æº–å‚™æ¥æ”¶
      if (socket.id) {
        socket.emit('viewer-ready', { roomId, viewerId: socket.id });
        console.log('[Viewer] re-emitted viewer-ready after broadcaster announcement');
      }
    });

  // æ¥æ”¶è¨Šæ¯ ï¼ˆä½¿ç”¨ userId ç”¢ç”Ÿ identity colorï¼‰
    // deterministic pastel-ish color generator based on userId (or username fallback)
    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
  const idForColor = data.userId || data.sender || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar">
                      <div class="text"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

  // Signaling events (kept silent in production)
  socket.on('offer', () => {});
  socket.on('answer', () => {});
  socket.on('candidate', () => {});

    // ç³»çµ±è¨Šæ¯
    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // If server tells this viewer the room has merged for PK, redirect to pk-viewer
    socket.on('pk-merged', ({ combinedRoom, leftOwner, rightOwner }) => {
      try {
        console.log('[viewer] received pk-merged', combinedRoom, leftOwner, rightOwner);
        if (!combinedRoom) return;
        const qs = new URLSearchParams({ room: combinedRoom });
        if (leftOwner) qs.set('leftOwner', String(leftOwner));
        if (rightOwner) qs.set('rightOwner', String(rightOwner));
        window.location.href = `/pk-viewer.html?${qs.toString()}`;
      } catch (e) { console.warn('pk-merged redirect failed', e); }
    });

    // reactions removed from normal viewer; PK pages now provide emoji UI
      // === æ™®é€šè§€çœ‹é é¢ Reactions åŠŸèƒ½ ===
      let showEmoji = true;   // é–¥é–€ï¼šæ§åˆ¶æ˜¯å¦é¡¯ç¤ºæœ¬åœ°å‹•ç•«
      let reacted = false;    // æ˜¯å¦å·²é€å‡ºéç¬¬ä¸€æ¬¡åæ‡‰ï¼ˆçµ±è¨ˆåªè¨˜ä¸€æ¬¡ï¼‰
      const valveBtn = document.getElementById('reactionValve');
    const reselectBtn = document.getElementById('reactionReselect');
    let reselectMode = false; // é‡é¸æ¨¡å¼ï¼šä¸‹ä¸€æ¬¡é»æ“Šè¡¨æƒ…å°‡é€å‡º reaction-change

      function spawnEmoji(type, opts = {}) {
        if (!showEmoji) return; // é–¥é–€é—œé–‰ä»å¯çµ±è¨ˆï¼Œä½†ä¸é¡¯ç¤ºå‹•ç•«
        const layer = document.getElementById('reactionLayer');
        if (!layer) return;
        const el = document.createElement('div');
        el.className = 'emoji-particle';
        el.textContent = (type === 'heart') ? 'ğŸ’–' : (type === 'laugh') ? 'ğŸ˜„' : (type === 'cry') ? 'ğŸ˜¢' : 'ğŸ‘';
        const ref = document.getElementById('video');
        let startX, startY;
        if (ref && typeof ref.getBoundingClientRect === 'function') {
          const r = ref.getBoundingClientRect();
          startX = r.right - 36 + (Math.random() - 0.5) * 30;
          startY = r.bottom - 22 + (Math.random() - 0.5) * 16;
        } else {
          startX = window.innerWidth * 0.75 + (Math.random() - 0.5) * 120;
          startY = window.innerHeight * 0.6 + (Math.random() - 0.5) * 100;
        }
        el.style.left = startX + 'px';
        el.style.top = startY + 'px';
        el.style.fontSize = (opts.size || (18 + Math.random() * 16)) + 'px';
        el.style.opacity = '1';
        document.body.appendChild(el);
        requestAnimationFrame(() => {
          const dx = (Math.random() - 0.5) * 50;
          const dy = - (190 + Math.random() * 140);
          const rot = (Math.random() - 0.5) * 40;
          el.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) scale(1.05)`;
          el.style.opacity = '0';
        });
        setTimeout(() => { try { el.remove(); } catch (e) {} }, 1150);
      }

      if (valveBtn) {
        valveBtn.addEventListener('click', () => {
          showEmoji = !showEmoji;
          valveBtn.classList.toggle('off', !showEmoji);
          valveBtn.textContent = showEmoji ? 'ğŸ” å‹•ç•«: é–‹å•Ÿ' : 'ğŸ” å‹•ç•«: é—œé–‰';
        });
      }

      if (reselectBtn) {
        reselectBtn.addEventListener('click', () => {
          reselectMode = true;
          reselectBtn.textContent = 'ğŸ¯ é‡é¸ä¸­â€¦';
          reselectBtn.disabled = true;
          // 5 ç§’å¾Œè‡ªå‹•é€€å‡ºé‡é¸æ¨¡å¼ï¼ˆé¿å…å¿˜è¨˜é»ï¼‰
          setTimeout(() => { if (reselectMode) { reselectMode = false; reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; } }, 5000);
        });
      }

      // æ›´æ–°ç†±é–€åæ‡‰çµ±è¨ˆ
      socket.on('reaction-stats', stats => {
        const el = document.getElementById('topReaction');
        if (!el) return;
        if (!stats || !stats.topType) { el.textContent = ''; return; }
        const emojiMap = { heart: 'ğŸ’–', laugh: 'ğŸ˜„', cry: 'ğŸ˜¢', like: 'ğŸ‘' };
        const e = emojiMap[stats.topType] || stats.topType;
        el.textContent = `${e} ${stats.topCount}`;
      });

      // æ¥æ”¶ä»–äººåæ‡‰å‹•ç•«ï¼ˆä¸å½±éŸ¿çµ±è¨ˆï¼‰
      socket.on('reaction', ({ type }) => { spawnEmoji(type); });

      // ç¶å®šæŒ‰éˆ•é€å‡º reactionï¼šæ¯æ¬¡éƒ½é€äº‹ä»¶ä»¥é¡¯ç¤ºå‹•ç•«ï¼›çµ±è¨ˆåƒ…è¨˜ç¬¬ä¸€æ¬¡
      document.querySelectorAll('.react-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const type = btn.dataset.type;
          if (!roomId || !type) return;
          // æ¯æ¬¡éƒ½é€å‡ºäº‹ä»¶ï¼Œè®“æ‰€æœ‰äººçœ‹åˆ°å‹•ç•«ï¼›ä¼ºæœå™¨åªæœƒåœ¨ç¬¬ä¸€æ¬¡è¨ˆå…¥çµ±è¨ˆ
          if (reselectMode) {
            socket.emit('reaction-change', { roomId, type });
            reselectMode = false;
            if (reselectBtn) { reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; }
          } else {
            socket.emit('reaction', { roomId, type });
            if (!reacted) reacted = true; // æ¨™è¨˜å·²åæ‡‰éä¸€æ¬¡
          }
          spawnEmoji(type, { size: 20 + Math.random() * 14 });
        });
      });
    // (ä¸Šæ–¹å·²æ¢å¾©æ™®é€šç›´æ’­çš„ reaction UI)

  const sendBtn = document.getElementById('sendBtn');
    // å‚³é€è¨Šæ¯åŠŸèƒ½
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId, user: username, userId, text, avatar });
      input.value = '';
    }

    // ç¶å®šé€å‡ºæŒ‰éˆ•
    document.getElementById('sendBtn').onclick = sendMessage;
    
    // ç¶å®š Enter éµ
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // é˜²æ­¢æ›è¡Œ
        sendMessage();
      }
    });



    // å…ˆç¦ç”¨é€å‡ºæŒ‰éˆ•ï¼Œç­‰ profile è¼‰å…¥æˆ–ç¢ºèªå¾Œå†å•Ÿç”¨ï¼ˆé¿å…é‚„æ²’è¼‰å…¥ username å°±é€å‡ºè¨Šæ¯ï¼‰
    sendBtn.disabled = true;
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) {
          username = data.username;
          avatar = data.avatar || '/uploads/default_avatar.png';
          userId = data.id || null;
        }
      })
      .catch(() => {})
      .finally(() => {
        // ç„¡è«–æ˜¯å¦ç™»å…¥ï¼Œéƒ½å…è¨±ä½¿ç”¨è€…é€å‡ºï¼ˆè‹¥æœªç™»å…¥å‰‡ä»ç‚ºåŒ¿åï¼‰
        sendBtn.disabled = false;
      });


    // é¡¯ç¤ºç›´æ’­è³‡è¨Š
    fetch(`/api/stream-info?room=${roomId}`)
      .then(res => res.json())
      .then(info => {
        document.getElementById('streamTitle').textContent = info.title;
        document.getElementById('streamDesc').textContent = info.description;
        document.getElementById('roomInfo').textContent = `æˆ¿é–“è™Ÿï¼š${roomId} | ä¸»æ’­ï¼š${info.username}`;
    });

      // reactions removed from normal viewer; use PK pages for emoji interactions

  // è§€çœ‹ç«¯ WebRTC - support multiple broadcasters (map by id) and handle duplicate offers
  const video = document.getElementById('video');
  const config = { 
    iceServers: [
      { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302", "stun:stun2.l.google.com:19302", "stun:stun3.l.google.com:19302", "stun:stun4.l.google.com:19302"] },
      {
        urls: ["turn:turnserver.open-telekom.de:3478", "turn:turnserver.open-telekom.de:3478?transport=tcp"],
        username: "webrtc",
        credential: "webrtcpassword"
      },
      {
        urls: ["turn:openrelay.metered.ca:80", "turn:openrelay.metered.ca:443", "turn:openrelay.metered.ca:443?transport=tcp"],
        username: "openrelayproject",
        credential: "openrelayproject"
      },
      {
        urls: ["turn:relay.metered.ca:80", "turn:relay.metered.ca:443"],
        username: "4f15fe3c0b2872b6dedb8d4d",
        credential: "2N8yzKQT6uHLiKM2"
      }
    ],
    iceCandidatePoolSize: 20,
    iceTransportPolicy: "all"
  };
  const peers = {}; // map of RTCPeerConnection by broadcaster socket id
  const pendingCandidates = {}; // store candidates that arrive before pc is created
  // ä¸å†ä½¿ç”¨èˆŠçš„ watcher æ©Ÿåˆ¶ï¼Œå·²æ”¹ç”¨ viewer-ready

    socket.on("offer", async (id, description) => {
      console.log('[Viewer] â¬‡ï¸ received offer from broadcaster', id);
      try {
        // if an existing pc exists for this id, close it to avoid state conflicts
        if (peers[id]) {
          console.log('[Viewer] closing existing peer for', id);
          try { peers[id].close(); } catch (e) {}
          delete peers[id];
          // clear video preview if it was attached to old pc
          try { if (video.srcObject) video.srcObject = null; } catch (e) {}
        }

        console.log('[Viewer] creating new RTCPeerConnection');
        const pc = new RTCPeerConnection(config);
        peers[id] = pc;

        // è¨ºæ–·ç‹€æ…‹è¿½è¹¤
        let iceCandidateCount = { host: 0, srflx: 0, relay: 0 };
        let hasRelay = false;
        let relayServer = null;

        let streamSet = false; // é¿å…é‡è¤‡è¨­ç½® srcObject
        let playAttempted = false; // é¿å…é‡è¤‡å˜—è©¦æ’­æ”¾
        let tracksReceived = { audio: false, video: false }; // è¿½è¹¤å“ªäº›è»Œé“å·²åˆ°é”
        
        pc.ontrack = event => {
          console.log('[Viewer] ontrack event received from', id);
          try {
            const stream = event.streams[0];
            
            // Debug: log incoming tracks
            try {
              const audios = stream && stream.getAudioTracks ? stream.getAudioTracks() : [];
              const videos = stream && stream.getVideoTracks ? stream.getVideoTracks() : [];
              console.log('[Viewer] tracks received - audio:', audios.length, 'video:', videos.length);
              
              // æ›´æ–°è»Œé“ç‹€æ…‹
              if (audios.length > 0) tracksReceived.audio = true;
              if (videos.length > 0) tracksReceived.video = true;
              
              console.log('[Viewer] tracks status - audio received:', tracksReceived.audio, 'video received:', tracksReceived.video);
            } catch (e) { console.warn('[Viewer] log tracks failed', e); }
            
            // åªåœ¨ç¬¬ä¸€æ¬¡æ”¶åˆ° track æ™‚è¨­ç½® srcObject
            if (!streamSet) {
              streamSet = true;
              video.srcObject = stream;
              video.muted = false; // é»˜èªä¸éœéŸ³ï¼Œç›´æ¥æ’­æ”¾è²éŸ³
              video.volume = 1.0;
              console.log('[Viewer] âœ“ set srcObject, muted=false, volume=1.0');
            }
            
            // ç¢ºä¿æ‰€æœ‰éŸ³è¨Š tracks éƒ½å•Ÿç”¨
            if (stream && stream.getAudioTracks) {
              stream.getAudioTracks().forEach(track => {
                track.enabled = true;
                console.log('[Viewer] âœ“ enabled audio track:', track.label, 'enabled:', track.enabled);
              });
            }
            
            // ç­‰å¾…éŸ³è¨Šå’Œè¦–è¨Šéƒ½åˆ°é”å¾Œå†æ’­æ”¾
            if (!playAttempted && tracksReceived.audio && tracksReceived.video) {
              playAttempted = true;
              console.log('[Viewer] ğŸ¬ both audio and video tracks received, ready to play');
              
              let retryCount = 0;
              const maxRetries = 10; // æœ€å¤šç­‰ 3 ç§’ (10 * 300ms)
              
              const tryPlay = () => {
                // æ’­æ”¾å‰ç¢ºèª stream ä¸­ç¢ºå¯¦æœ‰éŸ³è¦–è¨Šè»Œé“
                const currentStream = video.srcObject;
                if (currentStream) {
                  const audioTracks = currentStream.getAudioTracks();
                  const videoTracks = currentStream.getVideoTracks();
                  console.log('[Viewer] ğŸ“Š stream status before play (attempt', retryCount + 1, '/', maxRetries, ') - audio:', audioTracks.length, 'video:', videoTracks.length);
                  
                  // å¦‚æœè¦–è¨Šè»Œé“é‚„æ²’åŠ å…¥ streamï¼Œå†ç­‰ä¸€ä¸‹ï¼ˆä½†æœ‰æ¬¡æ•¸é™åˆ¶ï¼‰
                  if (videoTracks.length === 0 && retryCount < maxRetries) {
                    retryCount++;
                    console.log('[Viewer] â³ video track not in stream yet, retrying in 300ms... (', retryCount, '/', maxRetries, ')');
                    setTimeout(tryPlay, 300);
                    return;
                  }
                  
                  // å¦‚æœè¶…éé‡è©¦æ¬¡æ•¸é‚„æ˜¯æ²’æœ‰è¦–è¨Šï¼Œè¨˜éŒ„è­¦å‘Šä¸¦å¼·åˆ¶æ’­æ”¾
                  if (videoTracks.length === 0) {
                    console.warn('[Viewer] âš ï¸ video track still not in stream after', maxRetries, 'retries, playing anyway');
                    console.warn('[Viewer] ğŸ” debugging info - srcObject:', video.srcObject, 'all tracks:', currentStream.getTracks().map(t => ({ kind: t.kind, label: t.label, enabled: t.enabled, readyState: t.readyState })));
                  }
                } else {
                  console.error('[Viewer] âŒ no srcObject set on video element!');
                }
                
                // æ’­æ”¾ï¼ˆå¸¶è²éŸ³ï¼‰
                video.play().then(() => {
                  console.log('[Viewer] âœ“ video playing with audio, muted:', video.muted, 'volume:', video.volume);
                  const currentAudios = video.srcObject ? video.srcObject.getAudioTracks() : [];
                  const currentVideos = video.srcObject ? video.srcObject.getVideoTracks() : [];
                  console.log('[Viewer] âœ“ currently playing - audio tracks:', currentAudios.length, 'video tracks:', currentVideos.length);
                }).catch(err => {
                  console.warn('[Viewer] âš ï¸ autoplay with sound blocked, trying muted:', err.message);
                  // å¦‚æœå¸¶è²éŸ³çš„è‡ªå‹•æ’­æ”¾è¢«é˜»æ­¢ï¼Œé€€å›åˆ°éœéŸ³æ’­æ”¾
                  video.muted = true;
                  video.play().then(() => {
                    console.log('[Viewer] âœ“ playing muted (browser restriction), user can unmute via controls');
                  }).catch(err2 => {
                    console.error('[Viewer] âŒ even muted playback failed:', err2.message);
                  });
                  // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨
                  const playOnClick = () => {
                    video.play().then(() => {
                      video.muted = false;
                      console.log('[Viewer] âœ“ playing and unmuted after user interaction');
                    }).catch(e => console.warn('[Viewer] play failed even after click:', e));
                  };
                  document.addEventListener('click', playOnClick, { once: true });
                  console.log('[Viewer] ğŸ’¡ waiting for user click to start playback');
                });
              };
              
              // å»¶é² 200ms è®“ tracks å®Œå…¨ç©©å®š
              setTimeout(tryPlay, 200);
            }
            
            // è¶…æ™‚ä¿è­·ï¼šå¦‚æœ 5 ç§’å…§éƒ½æ²’æœ‰é–‹å§‹æ’­æ”¾ï¼Œå¼·åˆ¶å˜—è©¦æ’­æ”¾ï¼ˆå¯èƒ½åªæœ‰éŸ³è¨Šæˆ–åªæœ‰è¦–è¨Šï¼‰
            if (!playAttempted) {
              setTimeout(() => {
                if (!playAttempted) {
                  console.warn('[Viewer] â° timeout: forcing playback with available tracks');
                  console.log('[Viewer] tracks status at timeout - audio received:', tracksReceived.audio, 'video received:', tracksReceived.video);
                  
                  if (video.srcObject) {
                    const s = video.srcObject;
                    console.log('[Viewer] ğŸ” stream tracks at timeout:', s.getTracks().map(t => ({ kind: t.kind, label: t.label })));
                    
                    playAttempted = true;
                    video.muted = false; // å˜—è©¦å¸¶è²éŸ³æ’­æ”¾
                    video.play().then(() => {
                      console.log('[Viewer] âœ“ timeout playback started with audio');
                    }).catch(err => {
                      console.warn('[Viewer] âš ï¸ timeout playback with audio failed, trying muted:', err.message);
                      video.muted = true;
                      video.play().catch(err2 => {
                        console.error('[Viewer] âŒ timeout muted playback also failed:', err2.message);
                      });
                    });
                  }
                }
              }, 5000);
            }
            
          } catch (e) {
            console.error('[Viewer] âŒ ontrack handler failed:', e);
          }
        };

        pc.onicecandidate = evt => {
          if (evt.candidate) {
            const cand = evt.candidate;
            const type = cand.type; // host, srflx, relay
            const addr = cand.address || 'unknown';
            const proto = cand.protocol || 'unknown';
            console.log(`[Viewer] ğŸ“¡ ICE candidate (${type}): ${proto} ${addr}:${cand.port}`);
            
            // è¿½è¹¤å€™é¸é¡å‹
            if (iceCandidateCount[type] !== undefined) iceCandidateCount[type]++;
            if (type === 'relay') {
              hasRelay = true;
              relayServer = cand.relatedAddress || addr;
            }
            
            // æ›´æ–°é é¢è¨ºæ–·
            updateDiagPanel(pc, iceCandidateCount, hasRelay, relayServer);
            
            socket.emit('candidate', id, evt.candidate);
          } else {
            console.log(`[Viewer] âœ… ICE gathering complete for broadcaster ${id}`);
          }
        };
        
        // ç›£æ§é€£æ¥ç‹€æ…‹
        pc.oniceconnectionstatechange = () => {
          console.log(`[Viewer] ğŸŒ ICE connection (${id}): ${pc.iceConnectionState}`);
          updateDiagPanel(pc, iceCandidateCount, hasRelay, relayServer);
          if (pc.iceConnectionState === 'failed') {
            console.error(`[Viewer] âŒ ICE FAILED for broadcaster ${id} - may be TURN server issue`);
          }
        };
        
        pc.onconnectionstatechange = () => {
          console.log(`[Viewer] ğŸ”— Peer connection (${id}): ${pc.connectionState}`);
          updateDiagPanel(pc, iceCandidateCount, hasRelay, relayServer);
          if (pc.connectionState === 'failed') {
            console.error(`[Viewer] âŒ PEER CONNECTION FAILED for broadcaster ${id}`);
          }
        };

        // if candidates arrived earlier, add them now
        if (pendingCandidates[id] && pendingCandidates[id].length) {
          pendingCandidates[id].forEach(c => pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}));
          delete pendingCandidates[id];
        }

        console.log('[Viewer] setting remote description');
        await pc.setRemoteDescription(description);
        console.log('[Viewer] creating answer');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        console.log('[Viewer] sending answer to', id);
        socket.emit('answer', id, pc.localDescription);
      } catch (err) {
        console.error('[Viewer] âŒ Error handling offer:', err);
      }
    });

    socket.on('candidate', (id, candidate) => {
      const pc = peers[id];
      if (pc) {
        console.log('[Viewer] adding ICE candidate from', id);
        pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(err => {
          console.warn('[Viewer] failed to add ICE candidate:', err);
        });
      } else {
        console.log('[Viewer] storing ICE candidate for future peer', id);
        pendingCandidates[id] = pendingCandidates[id] || [];
        pendingCandidates[id].push(candidate);
      }
    });
  </script>
</body>
</html>
