<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>è§€çœ‹ç›´æ’­</title>
  <link rel="stylesheet" href="style-modern.css">

</head>
<body>
  <div class="viewer-layout">
    <div class="viewer-area">
      <div class="viewer-container">
        <h2 id="streamTitle">è¼‰å…¥ä¸­...</h2>
        <p id="streamDesc"></p>
          <video id="video" autoplay playsinline controls muted></video>
          <button id="unmuteBtn" style="position:absolute; right:16px; bottom:16px; z-index:999; padding:8px 10px; border-radius:6px; background:#222;color:#fff;border:none;display:none;">è§£é™¤éœéŸ³ ğŸ”Š</button>
          <!-- reactions (moved to PK pages) -->
        <p id="roomInfo"></p>
        <a href="index.html">è¿”å›é¦–é </a>
      </div>
    </div>

    <aside class="chat-area">
      <div id="chatContainer">
        <div id="messages"></div>
        <div class="chat-input-row">
          <input id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯...">
          <button id="sendBtn" disabled>é€å‡º</button>
        </div>
      </div>
    </aside>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    // debug helpers: connection state
    socket.on('connect', () => console.log('[viewer] socket connected', socket.id));
    socket.on('connect_error', (err) => console.warn('[viewer] socket connect_error', err && err.message));
    const params = new URLSearchParams(window.location.search);
    const roomId = params.get('room');
  let username = 'åŒ¿åç”¨æˆ¶';
  let avatar = '/uploads/default_avatar.png';
  let userId = null; // deterministic id for coloring chat names (from /api/profile)

    socket.emit('join-room', roomId);
    // request watcher role; also retry when a broadcaster appears
    socket.emit('watcher');
    socket.on('broadcaster', () => socket.emit('watcher'));

  // æ¥æ”¶è¨Šæ¯ ï¼ˆä½¿ç”¨ userId ç”¢ç”Ÿ identity colorï¼‰
    // deterministic pastel-ish color generator based on userId (or username fallback)
    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
  const idForColor = data.userId || data.sender || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar">
                      <div class="text"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

  // Signaling events (kept silent in production)
  socket.on('offer', () => {});
  socket.on('answer', () => {});
  socket.on('candidate', () => {});

    // ç³»çµ±è¨Šæ¯
    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // If server tells this viewer the room has merged for PK, redirect to pk-viewer
    socket.on('pk-merged', ({ combinedRoom, leftOwner, rightOwner }) => {
      try {
        console.log('[viewer] received pk-merged', combinedRoom, leftOwner, rightOwner);
        if (!combinedRoom) return;
        const qs = new URLSearchParams({ room: combinedRoom });
        if (leftOwner) qs.set('leftOwner', String(leftOwner));
        if (rightOwner) qs.set('rightOwner', String(rightOwner));
        window.location.href = `/pk-viewer.html?${qs.toString()}`;
      } catch (e) { console.warn('pk-merged redirect failed', e); }
    });

    // reactions removed from normal viewer; PK pages now provide emoji UI

  const sendBtn = document.getElementById('sendBtn');
    // å‚³é€è¨Šæ¯åŠŸèƒ½
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId, user: username, userId, text, avatar });
      input.value = '';
    }

    // ç¶å®šé€å‡ºæŒ‰éˆ•
    document.getElementById('sendBtn').onclick = sendMessage;
    
    // ç¶å®š Enter éµ
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // é˜²æ­¢æ›è¡Œ
        sendMessage();
      }
    });



    // å…ˆç¦ç”¨é€å‡ºæŒ‰éˆ•ï¼Œç­‰ profile è¼‰å…¥æˆ–ç¢ºèªå¾Œå†å•Ÿç”¨ï¼ˆé¿å…é‚„æ²’è¼‰å…¥ username å°±é€å‡ºè¨Šæ¯ï¼‰
    sendBtn.disabled = true;
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) {
          username = data.username;
          avatar = data.avatar || '/uploads/default_avatar.png';
          userId = data.id || null;
        }
      })
      .catch(() => {})
      .finally(() => {
        // ç„¡è«–æ˜¯å¦ç™»å…¥ï¼Œéƒ½å…è¨±ä½¿ç”¨è€…é€å‡ºï¼ˆè‹¥æœªç™»å…¥å‰‡ä»ç‚ºåŒ¿åï¼‰
        sendBtn.disabled = false;
      });


    // é¡¯ç¤ºç›´æ’­è³‡è¨Š
    fetch(`/api/stream-info?room=${roomId}`)
      .then(res => res.json())
      .then(info => {
        document.getElementById('streamTitle').textContent = info.title;
        document.getElementById('streamDesc').textContent = info.description;
        document.getElementById('roomInfo').textContent = `æˆ¿é–“è™Ÿï¼š${roomId} | ä¸»æ’­ï¼š${info.username}`;
    });

      // reactions removed from normal viewer; use PK pages for emoji interactions

  // è§€çœ‹ç«¯ WebRTC - support multiple broadcasters (map by id) and handle duplicate offers
  const video = document.getElementById('video');
  const peers = {}; // map of RTCPeerConnection by broadcaster socket id
  const pendingCandidates = {}; // store candidates that arrive before pc is created
  socket.emit("watcher");

    socket.on("offer", async (id, description) => {
      try {
        // if an existing pc exists for this id, close it to avoid state conflicts
        if (peers[id]) {
          try { peers[id].close(); } catch (e) {}
          delete peers[id];
          // clear video preview if it was attached to old pc
          try { if (video.srcObject) video.srcObject = null; } catch (e) {}
        }

        const pc = new RTCPeerConnection();
        peers[id] = pc;

        pc.ontrack = event => {
          try {
            video.muted = true;
            video.srcObject = event.streams[0];
            video.play().catch(() => {});
            const hasAudio = event.streams[0] && event.streams[0].getAudioTracks && event.streams[0].getAudioTracks().length > 0;
            const unmuteBtn = document.getElementById('unmuteBtn');
            if (hasAudio && unmuteBtn) {
              unmuteBtn.style.display = 'block';
              unmuteBtn.onclick = () => { try { video.muted = false; } catch (e) {} ; unmuteBtn.style.display = 'none'; };
            }
          } catch (e) {}
        };

        pc.onicecandidate = evt => {
          if (evt.candidate) socket.emit('candidate', id, evt.candidate);
        };

        // if candidates arrived earlier, add them now
        if (pendingCandidates[id] && pendingCandidates[id].length) {
          pendingCandidates[id].forEach(c => pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}));
          delete pendingCandidates[id];
        }

        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
  socket.emit('answer', id, pc.localDescription);
      } catch (err) {
        console.error('Error handling offer:', err);
      }
    });

    socket.on('candidate', (id, candidate) => {
      const pc = peers[id];
      if (pc) {
        pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(()=>{});
      } else {
        pendingCandidates[id] = pendingCandidates[id] || [];
        pendingCandidates[id].push(candidate);
      }
    });
  </script>
</body>
</html>
