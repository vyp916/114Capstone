<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>è§€çœ‹ç›´æ’­</title>
  <link rel="stylesheet" href="style-modern.css">

</head>
<body>
  <div class="viewer-layout">
    <div class="viewer-area">
      <div class="viewer-container">
        <div id="infoBar" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:6px;">
          <span>æˆ¿é–“è™Ÿï¼š<strong id="roomCode">---</strong></span>
          <span>ğŸ‘¥ åœ¨ç·šäººæ•¸ï¼š<strong id="viewerCount">0</strong></span>
          <button id="shareBtn" style="padding:6px 10px;border-radius:6px;border:1px solid #444;background:#111;color:#eee;cursor:pointer;">ğŸ“¤ åˆ†äº«é€£çµ</button>
        </div>
        <h2 id="streamTitle">è¼‰å…¥ä¸­...</h2>
        <p id="streamDesc"></p>
          <video id="video" autoplay playsinline controls></video>
          <!-- reactions (moved to PK pages) -->
            <!-- === Reactions (æ¢å¾©é PK è§€çœ‹ç«¯äº’å‹•) === -->
            <div id="reactionBar" style="margin:10px 0 4px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <button class="react-btn" data-type="heart" title="é€å‡º ğŸ’–">ğŸ’–</button>
              <button class="react-btn" data-type="laugh" title="é€å‡º ğŸ˜„">ğŸ˜„</button>
              <button class="react-btn" data-type="cry" title="é€å‡º ğŸ˜¢">ğŸ˜¢</button>
              <button class="react-btn" data-type="like" title="é€å‡º ğŸ‘">ğŸ‘</button>
              <button id="reactionValve" style="padding:6px 14px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:13px;cursor:pointer;">ğŸ” å‹•ç•«: é–‹å•Ÿ</button>
              <button id="reactionReselect" style="padding:6px 14px;border-radius:30px;border:1px solid #444;background:#111;color:#eee;font-size:13px;cursor:pointer;">ğŸ¯ é‡é¸è¡¨æƒ…</button>
              <span id="topReaction" style="margin-left:auto;font-size:14px;color:#ffd2e6;"></span>
            </div>
            <div id="reactionLayer" style="position:fixed; right:20px; bottom:100px; width:160px; height:50vh; pointer-events:none; overflow:visible; z-index:9999;"></div>
            <style>
              .react-btn { width:52px;height:52px;border-radius:50%;border:none;font-size:24px;cursor:pointer;background:#222;color:#fff;box-shadow:0 4px 10px rgba(0,0,0,.45);transition:transform .15s, box-shadow .15s; }
              .react-btn:hover { transform:translateY(-3px) scale(1.06); box-shadow:0 8px 18px rgba(0,0,0,.55); }
              .react-btn:disabled { filter:grayscale(70%); opacity:.55; cursor:not-allowed; }
              #reactionValve.off { background:#300; color:#f88; }
              .emoji-particle { position:fixed; font-size:20px; opacity:0; transform:translate3d(0,0,0) scale(.9); transition:transform 1.1s cubic-bezier(.2,.9,.2,1), opacity 1.1s linear; will-change:transform,opacity; pointer-events:none; }
            </style>
        <p id="roomInfo"></p>
        <a href="index.html">è¿”å›é¦–é </a>
      </div>
    </div>

    <aside class="chat-area">
      <div id="chatContainer">
        <div id="messages"></div>
        <div class="chat-input-row">
          <input id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯...">
          <button id="sendBtn" disabled>é€å‡º</button>
        </div>
      </div>
    </aside>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const params = new URLSearchParams(window.location.search);
    const roomId = params.get('room');
  // é¡¯ç¤ºæˆ¿é–“è™Ÿ
  try { const rc = document.getElementById('roomCode'); if (rc) rc.textContent = roomId || '---'; } catch (e) {}
  let username = 'åŒ¿åç”¨æˆ¶';
  let avatar = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Crect fill="%23e0e0e0" width="200" height="200"/%3E%3Ccircle cx="100" cy="70" r="40" fill="%23999"/%3E%3Cellipse cx="100" cy="150" rx="50" ry="40" fill="%23999"/%3E%3C/svg%3E';
  let userId = null; // deterministic id for coloring chat names (from /api/profile)

    // ç­‰å¾… socket é€£ç·šå®Œæˆå¾Œæ‰ç™¼é€ viewer-ready
    function notifyViewerReady() {
      if (socket.id) {
        socket.emit('join-room', roomId);
        socket.emit('viewer-ready', { roomId, viewerId: socket.id });
      } else {
        setTimeout(notifyViewerReady, 100);
      }
    }
    
    // å¦‚æœå·²ç¶“é€£ç·šå°±ç«‹å³ç™¼é€ï¼Œå¦å‰‡ç­‰å¾… connect äº‹ä»¶
    if (socket.connected && socket.id) {
      notifyViewerReady();
    } else {
      socket.on('connect', notifyViewerReady);
    }
    
    // åœ¨ç·šäººæ•¸æ›´æ–°
    socket.on('viewer-count', count => {
      try { const vc = document.getElementById('viewerCount'); if (vc) vc.textContent = String(count); } catch (e) {}
    });

    // åˆ†äº«é€£çµæŒ‰éˆ•
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
      shareBtn.onclick = () => {
        const url = `${window.location.origin}/viewer.html?room=${encodeURIComponent(roomId || '')}`;
        navigator.clipboard.writeText(url).then(() => {
          alert(`ğŸ“ å·²è¤‡è£½åˆ†äº«é€£çµï¼š\n${url}`);
        }).catch(() => {
          alert('ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹æ‰‹å‹•è¤‡è£½ï¼š\n' + url);
        });
      };
    }
    
    // ç›£è½ broadcaster äº‹ä»¶ï¼ˆä¿æŒç›¸å®¹æ€§ï¼‰
    socket.on('broadcaster', (data) => {
      // broadcaster å·²åœ¨ç·šï¼Œå†æ¬¡é€šçŸ¥æº–å‚™æ¥æ”¶
      if (socket.id) {
        socket.emit('viewer-ready', { roomId, viewerId: socket.id });
      }
    });

  // æ¥æ”¶è¨Šæ¯ ï¼ˆä½¿ç”¨ userId ç”¢ç”Ÿ identity colorï¼‰
    // deterministic pastel-ish color generator based on userId (or username fallback)
    function colorForId(id) {
      if (!id) id = 'anon';
      let h = 0;
      for (let i = 0; i < id.length; i++) h = (h << 5) - h + id.charCodeAt(i) | 0;
      const hue = Math.abs(h) % 360;
      const sat = 68;
      const light = 58;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    socket.on('chat-message', data => {
      const box = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.classList.add('message');
      const displayName = data.isHost ? `ğŸ‘‘ ${data.user}` : data.user;
  const idForColor = data.userId || data.sender || data.user || 'anon';
      const nameColor = colorForId(String(idForColor));
      msg.innerHTML = `<img src="${data.avatar}" alt="avatar">
                      <div class="text"><strong style="color:${nameColor}">${displayName}</strong><br>${data.text}</div>`;
      box.appendChild(msg);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

  // Signaling events (kept silent in production)
  socket.on('offer', () => {});
  socket.on('answer', () => {});
  socket.on('candidate', () => {});

    // ç³»çµ±è¨Šæ¯
    socket.on('system-message', text => {
      const box = document.getElementById('messages');
      const sys = document.createElement('div');
      sys.classList.add('system-message');
      sys.textContent = text;
      box.appendChild(sys);
      // keep only last 20 messages
      while (box.children.length > 20) box.removeChild(box.firstChild);
      box.scrollTop = box.scrollHeight;
    });

    // If server tells this viewer the room has merged for PK, redirect to pk-viewer
    socket.on('pk-merged', ({ combinedRoom, leftOwner, rightOwner }) => {
      try {
        if (!combinedRoom) return;
        const qs = new URLSearchParams({ room: combinedRoom });
        if (leftOwner) qs.set('leftOwner', String(leftOwner));
        if (rightOwner) qs.set('rightOwner', String(rightOwner));
        window.location.href = `/pk-viewer.html?${qs.toString()}`;
      } catch (e) { }
    });

    // reactions removed from normal viewer; PK pages now provide emoji UI
      // === æ™®é€šè§€çœ‹é é¢ Reactions åŠŸèƒ½ ===
      let showEmoji = true;   // é–¥é–€ï¼šæ§åˆ¶æ˜¯å¦é¡¯ç¤ºæœ¬åœ°å‹•ç•«
      let reacted = false;    // æ˜¯å¦å·²é€å‡ºéç¬¬ä¸€æ¬¡åæ‡‰ï¼ˆçµ±è¨ˆåªè¨˜ä¸€æ¬¡ï¼‰
      const valveBtn = document.getElementById('reactionValve');
    const reselectBtn = document.getElementById('reactionReselect');
    let reselectMode = false; // é‡é¸æ¨¡å¼ï¼šä¸‹ä¸€æ¬¡é»æ“Šè¡¨æƒ…å°‡é€å‡º reaction-change

      function spawnEmoji(type, opts = {}) {
        if (!showEmoji) return; // é–¥é–€é—œé–‰ä»å¯çµ±è¨ˆï¼Œä½†ä¸é¡¯ç¤ºå‹•ç•«
        const layer = document.getElementById('reactionLayer');
        if (!layer) return;
        const el = document.createElement('div');
        el.className = 'emoji-particle';
        el.textContent = (type === 'heart') ? 'ğŸ’–' : (type === 'laugh') ? 'ğŸ˜„' : (type === 'cry') ? 'ğŸ˜¢' : 'ğŸ‘';
        const ref = document.getElementById('video');
        let startX, startY;
        if (ref && typeof ref.getBoundingClientRect === 'function') {
          const r = ref.getBoundingClientRect();
          startX = r.right - 36 + (Math.random() - 0.5) * 30;
          startY = r.bottom - 22 + (Math.random() - 0.5) * 16;
        } else {
          startX = window.innerWidth * 0.75 + (Math.random() - 0.5) * 120;
          startY = window.innerHeight * 0.6 + (Math.random() - 0.5) * 100;
        }
        el.style.left = startX + 'px';
        el.style.top = startY + 'px';
        el.style.fontSize = (opts.size || (18 + Math.random() * 16)) + 'px';
        el.style.opacity = '1';
        document.body.appendChild(el);
        requestAnimationFrame(() => {
          const dx = (Math.random() - 0.5) * 50;
          const dy = - (190 + Math.random() * 140);
          const rot = (Math.random() - 0.5) * 40;
          el.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) scale(1.05)`;
          el.style.opacity = '0';
        });
        setTimeout(() => { try { el.remove(); } catch (e) {} }, 1150);
      }

      if (valveBtn) {
        valveBtn.addEventListener('click', () => {
          showEmoji = !showEmoji;
          valveBtn.classList.toggle('off', !showEmoji);
          valveBtn.textContent = showEmoji ? 'ğŸ” å‹•ç•«: é–‹å•Ÿ' : 'ğŸ” å‹•ç•«: é—œé–‰';
        });
      }

      if (reselectBtn) {
        reselectBtn.addEventListener('click', () => {
          reselectMode = true;
          reselectBtn.textContent = 'ğŸ¯ é‡é¸ä¸­â€¦';
          reselectBtn.disabled = true;
          // 5 ç§’å¾Œè‡ªå‹•é€€å‡ºé‡é¸æ¨¡å¼ï¼ˆé¿å…å¿˜è¨˜é»ï¼‰
          setTimeout(() => { if (reselectMode) { reselectMode = false; reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; } }, 5000);
        });
      }

      // æ›´æ–°ç†±é–€åæ‡‰çµ±è¨ˆ
      socket.on('reaction-stats', stats => {
        const el = document.getElementById('topReaction');
        if (!el) return;
        if (!stats || !stats.topType) { el.textContent = ''; return; }
        const emojiMap = { heart: 'ğŸ’–', laugh: 'ğŸ˜„', cry: 'ğŸ˜¢', like: 'ğŸ‘' };
        const e = emojiMap[stats.topType] || stats.topType;
        el.textContent = `${e} ${stats.topCount}`;
      });

      // æ¥æ”¶ä»–äººåæ‡‰å‹•ç•«ï¼ˆä¸å½±éŸ¿çµ±è¨ˆï¼‰
      socket.on('reaction', ({ type }) => { spawnEmoji(type); });

      // ç¶å®šæŒ‰éˆ•é€å‡º reactionï¼šæ¯æ¬¡éƒ½é€äº‹ä»¶ä»¥é¡¯ç¤ºå‹•ç•«ï¼›çµ±è¨ˆåƒ…è¨˜ç¬¬ä¸€æ¬¡
      document.querySelectorAll('.react-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const type = btn.dataset.type;
          if (!roomId || !type) return;
          // æ¯æ¬¡éƒ½é€å‡ºäº‹ä»¶ï¼Œè®“æ‰€æœ‰äººçœ‹åˆ°å‹•ç•«ï¼›ä¼ºæœå™¨åªæœƒåœ¨ç¬¬ä¸€æ¬¡è¨ˆå…¥çµ±è¨ˆ
          if (reselectMode) {
            socket.emit('reaction-change', { roomId, type });
            reselectMode = false;
            if (reselectBtn) { reselectBtn.textContent = 'ğŸ¯ é‡é¸è¡¨æƒ…'; reselectBtn.disabled = false; }
          } else {
            socket.emit('reaction', { roomId, type });
            if (!reacted) reacted = true; // æ¨™è¨˜å·²åæ‡‰éä¸€æ¬¡
          }
          spawnEmoji(type, { size: 20 + Math.random() * 14 });
        });
      });
    // (ä¸Šæ–¹å·²æ¢å¾©æ™®é€šç›´æ’­çš„ reaction UI)

  const sendBtn = document.getElementById('sendBtn');
    // å‚³é€è¨Šæ¯åŠŸèƒ½
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (!text) return;
      socket.emit('chat-message', { roomId, user: username, userId, text, avatar });
      input.value = '';
    }

    // ç¶å®šé€å‡ºæŒ‰éˆ•
    document.getElementById('sendBtn').onclick = sendMessage;
    
    // ç¶å®š Enter éµ
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // é˜²æ­¢æ›è¡Œ
        sendMessage();
      }
    });



    // å…ˆç¦ç”¨é€å‡ºæŒ‰éˆ•ï¼Œç­‰ profile è¼‰å…¥æˆ–ç¢ºèªå¾Œå†å•Ÿç”¨ï¼ˆé¿å…é‚„æ²’è¼‰å…¥ username å°±é€å‡ºè¨Šæ¯ï¼‰
    sendBtn.disabled = true;
    fetch('/api/profile', { credentials: 'include' })
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (data) {
          username = data.username;
          avatar = data.avatar || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Crect fill="%23e0e0e0" width="200" height="200"/%3E%3Ccircle cx="100" cy="70" r="40" fill="%23999"/%3E%3Cellipse cx="100" cy="150" rx="50" ry="40" fill="%23999"/%3E%3C/svg%3E';
          userId = data.id || null;
        }
      })
      .catch(() => {})
      .finally(() => {
        // ç„¡è«–æ˜¯å¦ç™»å…¥ï¼Œéƒ½å…è¨±ä½¿ç”¨è€…é€å‡ºï¼ˆè‹¥æœªç™»å…¥å‰‡ä»ç‚ºåŒ¿åï¼‰
        sendBtn.disabled = false;
      });


    // é¡¯ç¤ºç›´æ’­è³‡è¨Š
    fetch(`/api/stream-info?room=${roomId}`)
      .then(res => res.json())
      .then(info => {
        document.getElementById('streamTitle').textContent = info.title;
        document.getElementById('streamDesc').textContent = info.description;
        document.getElementById('roomInfo').textContent = `æˆ¿é–“è™Ÿï¼š${roomId} | ä¸»æ’­ï¼š${info.username}`;
    });

      // reactions removed from normal viewer; use PK pages for emoji interactions

  // è§€çœ‹ç«¯ WebRTC - support multiple broadcasters (map by id) and handle duplicate offers
  const video = document.getElementById('video');
  const config = { 
    iceServers: [
      { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302", "stun:stun2.l.google.com:19302", "stun:stun3.l.google.com:19302", "stun:stun4.l.google.com:19302"] },
      { urls: "stun:stun.stunprotocol.org:3478" },
      { urls: "stun:stun1.stunprotocol.org:3478" },
      { urls: ["stun:stunserver.org:3478", "stun:stunserver.stunprotocol.org:3478"] },
      {
        urls: ["turn:openrelay.metered.ca:80", "turn:openrelay.metered.ca:443", "turn:openrelay.metered.ca:443?transport=tcp"],
        username: "openrelayproject",
        credential: "openrelayproject"
      }
    ],
    iceCandidatePoolSize: 20,
    iceTransportPolicy: "all"
  };
  const peers = {}; // map of RTCPeerConnection by broadcaster socket id
  const pendingCandidates = {}; // store candidates that arrive before pc is created
  // ä¸å†ä½¿ç”¨èˆŠçš„ watcher æ©Ÿåˆ¶ï¼Œå·²æ”¹ç”¨ viewer-ready

    socket.on("offer", async (id, description) => {
      try {
        // if an existing pc exists for this id, close it to avoid state conflicts
        if (peers[id]) {
          try { peers[id].close(); } catch (e) {}
          delete peers[id];
          // clear video preview if it was attached to old pc
          try { if (video.srcObject) video.srcObject = null; } catch (e) {}
        }

        const pc = new RTCPeerConnection(config);
        peers[id] = pc;

        // è¨ºæ–·ç‹€æ…‹è¿½è¹¤
        let iceCandidateCount = { host: 0, srflx: 0, relay: 0 };
        let hasRelay = false;
        let relayServer = null;

        let streamSet = false; // é¿å…é‡è¤‡è¨­ç½® srcObject
        let playAttempted = false; // é¿å…é‡è¤‡å˜—è©¦æ’­æ”¾
        let tracksReceived = { audio: false, video: false }; // è¿½è¹¤å“ªäº›è»Œé“å·²åˆ°é”
        
        pc.ontrack = event => {
          try {
            const stream = event.streams[0];
            
            // åªåœ¨ç¬¬ä¸€æ¬¡æ”¶åˆ° track æ™‚è¨­ç½® srcObject
            if (!streamSet) {
              streamSet = true;
              video.srcObject = stream;
              video.muted = false;
              video.volume = 1.0;
            }
            
            // ç¢ºä¿æ‰€æœ‰éŸ³è¨Š tracks éƒ½å•Ÿç”¨
            if (stream && stream.getAudioTracks) {
              stream.getAudioTracks().forEach(track => {
                track.enabled = true;
              });
            }
            
            // ç­‰å¾…éŸ³è¨Šå’Œè¦–è¨Šéƒ½åˆ°é”å¾Œå†æ’­æ”¾
            if (!playAttempted && tracksReceived.audio && tracksReceived.video) {
              playAttempted = true;
              
              let retryCount = 0;
              const maxRetries = 10;
              
              const tryPlay = () => {
                // æ’­æ”¾å‰ç¢ºèª stream ä¸­ç¢ºå¯¦æœ‰éŸ³è¦–è¨Šè»Œé“
                const currentStream = video.srcObject;
                if (currentStream) {
                  const audioTracks = currentStream.getAudioTracks();
                  const videoTracks = currentStream.getVideoTracks();
                  
                  // å¦‚æœè¦–è¨Šè»Œé“é‚„æ²’åŠ å…¥ streamï¼Œå†ç­‰ä¸€ä¸‹ï¼ˆä½†æœ‰æ¬¡æ•¸é™åˆ¶ï¼‰
                  if (videoTracks.length === 0 && retryCount < maxRetries) {
                    retryCount++;
                    setTimeout(tryPlay, 300);
                    return;
                  }
                }
                
                // æ’­æ”¾ï¼ˆå¸¶è²éŸ³ï¼‰
                video.play().then(() => {
                }).catch(err => {
                  // å¦‚æœå¸¶è²éŸ³çš„è‡ªå‹•æ’­æ”¾è¢«é˜»æ­¢ï¼Œé€€å›åˆ°éœéŸ³æ’­æ”¾
                  video.muted = true;
                  video.play().then(() => {
                  }).catch(err2 => {
                  });
                  // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨
                  const playOnClick = () => {
                    video.play().then(() => {
                      video.muted = false;
                    }).catch(e => {});
                  };
                  document.addEventListener('click', playOnClick, { once: true });
                });
              };
              
              // å»¶é² 200ms è®“ tracks å®Œå…¨ç©©å®š
              setTimeout(tryPlay, 200);
            }
            
            // è¶…æ™‚ä¿è­·ï¼šå¦‚æœ 5 ç§’å…§éƒ½æ²’æœ‰é–‹å§‹æ’­æ”¾ï¼Œå¼·åˆ¶å˜—è©¦æ’­æ”¾ï¼ˆå¯èƒ½åªæœ‰éŸ³è¨Šæˆ–åªæœ‰è¦–è¨Šï¼‰
            if (!playAttempted) {
              setTimeout(() => {
                if (!playAttempted) {
                  if (video.srcObject) {
                    const s = video.srcObject;
                    playAttempted = true;
                    video.muted = false;
                    video.play().then(() => {
                    }).catch(err => {
                      video.muted = true;
                      video.play().catch(err2 => {
                      });
                    });
                  }
                }
              }, 5000);
            }
            
          } catch (e) {
          }
        };

        pc.onicecandidate = evt => {
          if (evt.candidate) {
            socket.emit('candidate', id, evt.candidate);
          }
        };
        
        // ç›£æ§é€£æ¥ç‹€æ…‹
        pc.oniceconnectionstatechange = () => {
          if (pc.iceConnectionState === 'failed') {
          }
        };
        
        pc.onconnectionstatechange = () => {
          if (pc.connectionState === 'failed') {
          }
        };

        // if candidates arrived earlier, add them now
        if (pendingCandidates[id] && pendingCandidates[id].length) {
          pendingCandidates[id].forEach(c => pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}));
          delete pendingCandidates[id];
        }

        console.log('[Viewer] setting remote description');
        await pc.setRemoteDescription(description);
        console.log('[Viewer] creating answer');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        console.log('[Viewer] sending answer to', id);
        socket.emit('answer', id, pc.localDescription);
      } catch (err) {
        console.error('[Viewer] âŒ Error handling offer:', err);
      }
    });

    socket.on('candidate', (id, candidate) => {
      const pc = peers[id];
      if (pc) {
        console.log('[Viewer] adding ICE candidate from', id);
        pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(err => {
          console.warn('[Viewer] failed to add ICE candidate:', err);
        });
      } else {
        console.log('[Viewer] storing ICE candidate for future peer', id);
        pendingCandidates[id] = pendingCandidates[id] || [];
        pendingCandidates[id].push(candidate);
      }
    });
  </script>
</body>
</html>
